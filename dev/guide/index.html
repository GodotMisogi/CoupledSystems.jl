<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started · CoupledSystems.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CoupledSystems.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Getting Started</a><ul class="internal"><li><a class="tocitem" href="#Defining-System-Variables"><span>Defining System Variables</span></a></li><li><a class="tocitem" href="#Constructing-Explicit-Components"><span>Constructing Explicit Components</span></a></li><li><a class="tocitem" href="#Converting-Explicit-Components-into-Implicit-Components"><span>Converting Explicit Components into Implicit Components</span></a></li><li><a class="tocitem" href="#Constructing-an-Implicit-System"><span>Constructing an Implicit System</span></a></li><li><a class="tocitem" href="#Coupling-an-Implicit-Component-with-a-Solver-to-Construct-an-Explicit-Component"><span>Coupling an Implicit Component with a Solver to Construct an Explicit Component</span></a></li><li><a class="tocitem" href="#Combining-Explicit-Components-into-an-Explicit-System"><span>Combining Explicit Components into an Explicit System</span></a></li><li><a class="tocitem" href="#Querying-Explicit-Components-and/or-Systems"><span>Querying Explicit Components and/or Systems</span></a></li><li><a class="tocitem" href="#Verifying-Derivatives"><span>Verifying Derivatives</span></a></li><li><a class="tocitem" href="#Final-Notes"><span>Final Notes</span></a></li></ul></li><li><a class="tocitem" href="../theory/">Theory</a></li><li><a class="tocitem" href="../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Getting Started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting Started</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/CoupledSystems.jl/blob/master/docs/src/guide.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Getting-Started:-The-Sellar-Problem"><a class="docs-heading-anchor" href="#Getting-Started:-The-Sellar-Problem">Getting Started: The Sellar Problem</a><a id="Getting-Started:-The-Sellar-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-Started:-The-Sellar-Problem" title="Permalink"></a></h1><p>The Sellar problem is is a two-discipline toy problem introduced by R.S. Sellar, S.M. Batill, and J.E. Renaud in &quot;Response Surface Based, Concurrent Subspace Optimization for Multidisciplinary System Design&quot;.  The problem itself is non-physical, but it provides a simple example with which to demonstrate multidisciplinary coupling and analysis capabilities.</p><p>Each of the two disciplines in the Sellar problem consists of a single explicit equation.  The output of each discipline is used as an input to the other discipline.  Together, the two disciplines form a nonlinear system of equations which must be solved in order to obtain valid outputs.  The outputs of the coupled system of equations are used to construct objective and constraint functions for an optimization. The following is an XDSM diagram of the problem structure.</p><p><img src="../sellar-xdsm1.svg" alt/></p><p>Our goal is to manipulate this problem in order to create a single explicit function/component which defines the objective and constraint values as well as their derivatives with respect to the design variables (the inputs).  In other words, we would like to take the diagram shown above and convert it to the following one-component system, and propagate derivatives while doing so.</p><p><img src="../sellar-xdsm-final.svg" alt/></p><h2 id="Defining-System-Variables"><a class="docs-heading-anchor" href="#Defining-System-Variables">Defining System Variables</a><a id="Defining-System-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-System-Variables" title="Permalink"></a></h2><p>Let&#39;s start by loading the package and defining the system variables.  This can be done with the <code>@var</code> macro.</p><pre><code class="language-julia">using CoupledSystems

# Name all variables and give them default values
@var x = 0.0
@var y1 = 0.0
@var y2 = 0.0
@var z1 = 0.0
@var z2 = 0.0
@var f = 0.0
@var g1 = 0.0
@var g2 = 0.0</code></pre><p>Each variable&#39;s name is used to define connections between components. The value assigned to each variable is generally used just to define the size and type of each variable, but it may also be used to generate an initial guess for a nonlinear solver.</p><h2 id="Constructing-Explicit-Components"><a class="docs-heading-anchor" href="#Constructing-Explicit-Components">Constructing Explicit Components</a><a id="Constructing-Explicit-Components-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-Explicit-Components" title="Permalink"></a></h2><p>Now that we have defined our system variables, we can use them to construct each of the components in the Sellar problem.  Since all of the components (when considered in isolation) are explicit, we model them as such.  </p><pre><code class="language-julia"># --- Define Discipline 1 --- #

# describe function inputs/outputs
fin = (x, y2, z1, z2) # inputs
fout = (y1,) # normal outputs
fout_m = () # in-place (mutating) outputs

# create function for discipline 1
function f_d1(x, y2, z1, z2)
    y1 = z1^2 + z2 + x - 0.2*y2
    return y1
end

# construct explicit component for discipline 1
d1 = ExplicitComponent(f_d1, fin, fout, fout_m; deriv=ForwardFD())

# --- Define Discipline 2 --- #

# describe function inputs/outputs
fin = (y1, z1, z2) # inputs
fout = (y2,) # normal outputs
fout_m = () # in-place (mutating) outputs

# create function for discipline 2
function f_d2(y1, z1, z2)
    y2 = sqrt(y1) + z1 + z2
    return y2
end

# construct explicit component for discipline 2
d2 = ExplicitComponent(f_d2, fin, fout, fout_m; deriv=ForwardFD())

# --- Define Objective --- #

# describe function inputs/outputs
fin = (x, y1, y2, z1) # inputs
fout = (f,) # normal outputs
fout_m = () # in-place (mutating) outputs

# create objective function
function f_obj(x, y1, y2, z1)
    f = x^2 + z1 + y1 + exp(-y2) # objective
    return f
end

# construct explicit component for objective
obj = ExplicitComponent(f_obj, fin, fout, fout_m; deriv=ForwardFD())

# --- Define Constraint 1 --- #

# describe function inputs/outputs
fin = (y1,) # inputs
fout = (g1,) # normal outputs
fout_m = () # in-place (mutating) outputs

# define first constraint function
function f_c1(y1)
    g1 = 3.16 - y1
    return g1
end

# construct explicit component for constraint 1
c1 = ExplicitComponent(f_c1, fin, fout, fout_m; deriv=ForwardFD())

# --- Define Constraint 2 --- #

# describe function inputs/outputs
fin = (y2,) # inputs
fout = (g2,) # normal outputs
fout_m = () # in-place (mutating) outputs

# define second constraint function
function f_c2(y2)
    g2 = y2 - 24.0
    return g2
end

# construct explicit component for constraint 2
c2 = ExplicitComponent(f_c2, fin, fout, fout_m; deriv=ForwardFD())</code></pre><p>The method by which to calculate the jacobian of each component is provided through the <code>deriv</code> keyword argument.  Possible jacobian calculation methods include:</p><ul><li>Forward Finite Differencing (<a href="../library/#CoupledSystems.ForwardFD"><code>ForwardFD()</code></a>, default)</li><li>Central Finite Differencing (<a href="../library/#CoupledSystems.CentralFD"><code>CentralFD()</code></a>)</li><li>Complex Step Finite Differencing (<a href="../library/#CoupledSystems.ComplexFD"><code>ComplexFD()</code></a>)</li><li>Forward-Mode Automatic Differentiation (<a href="../library/#CoupledSystems.ForwardAD"><code>ForwardAD()</code></a>)</li><li>Reverse-Mode Automatic Differentiation (<a href="../library/#CoupledSystems.ReverseAD"><code>ReverseAD()</code></a>)  </li></ul><p>You can even provide your own jacobian function through the <code>df</code> keyword argument.</p><h2 id="Converting-Explicit-Components-into-Implicit-Components"><a class="docs-heading-anchor" href="#Converting-Explicit-Components-into-Implicit-Components">Converting Explicit Components into Implicit Components</a><a id="Converting-Explicit-Components-into-Implicit-Components-1"></a><a class="docs-heading-anchor-permalink" href="#Converting-Explicit-Components-into-Implicit-Components" title="Permalink"></a></h2><p>We would like to be able to converge all interdependent components simultaneously.  This can be done with the help of a nonlinear solver.  Let&#39;s go ahead and add one to the XDSM diagram.</p><p><img src="../sellar-xdsm2.svg" alt/></p><p>Notice that the two disciplinary components have been converted to implicit components so that they can provide residual vectors to the nonlinear solver.  The nonlinear solver then drives these residuals to zero and provides the final states/outputs <code>y_1</code> and <code>y_2</code> to the rest of the system.  Let&#39;s go ahead and convert our explicit components to implicit components so that they can be used to provide residual vectors (and associated derivatives) to the nonlinear solver.</p><pre><code class="language-julia"># convert discipline 1 into an implicit component
d1i = ImplicitComponent(d1)

# convert discipline 2 into an implicit component
d2i = ImplicitComponent(d2)</code></pre><h2 id="Constructing-an-Implicit-System"><a class="docs-heading-anchor" href="#Constructing-an-Implicit-System">Constructing an Implicit System</a><a id="Constructing-an-Implicit-System-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-an-Implicit-System" title="Permalink"></a></h2><p>At this point we combine the two implicit components to create a single set of residual equations.  The state variables of the corresponding system correspond to the outputs of all of its subcomponents.</p><pre><code class="language-julia"># components in the implicit system
components_isys = (d1i, d2i)

# inputs to the implicit system
inputs_isys = (x, z1, z2)

# outputs are the subcomponent outputs

# implicit system construction
isys = ImplicitSystem(components_isys, inputs_isys)</code></pre><p>It is also possible to construct an implicit system directly from explicit components.  In this case, explicit components are converted to implicit components during construction.</p><pre><code class="language-julia"># components in the implicit system
components_isys = (d1, d2)

# inputs to the implicit system
inputs_isys = (x, z1, z2)

# implicit system construction
isys = ImplicitSystem(components_isys, inputs_isys)</code></pre><p>Let&#39;s now update the XDSM diagram to account for the newly constructed implicit system.</p><p><img src="../sellar-xdsm3.svg" alt/></p><h2 id="Coupling-an-Implicit-Component-with-a-Solver-to-Construct-an-Explicit-Component"><a class="docs-heading-anchor" href="#Coupling-an-Implicit-Component-with-a-Solver-to-Construct-an-Explicit-Component">Coupling an Implicit Component with a Solver to Construct an Explicit Component</a><a id="Coupling-an-Implicit-Component-with-a-Solver-to-Construct-an-Explicit-Component-1"></a><a class="docs-heading-anchor-permalink" href="#Coupling-an-Implicit-Component-with-a-Solver-to-Construct-an-Explicit-Component" title="Permalink"></a></h2><p>Now that we have a single implicit system of equations, let&#39;s couple it with a nonlinear solver in order to solve for the outputs.  We represent the resulting component as an explicit component.  Note that the initial guess for the Newton solver corresponds to the default values of the variables <code>y1</code> and <code>y2</code>.</p><pre><code class="language-julia">mda = ExplicitComponent(isys; solver=Newton())</code></pre><p>The default outputs for an implicit component/system which is converted to a explicit component are the state variables of the system.  However, it is also possible to provide only a subset of the state variables as outputs.  This has the potential to reduce computational expenses related to derivative computations.</p><pre><code class="language-julia">fout = (y1, y2)
mda = ExplicitComponent(isys, fout; solver=Newton())</code></pre><p>Another option for reducing the computational expenses involved with derivative computations is to include an output function (expressed as an explicit component) when coupling an implicit system with a nonlinear solver.  An output function calculates a small number of outputs (relative to the number of state variables) from the inputs and state variables of an implicit system.</p><p>Since all state variables are outputs in this toy problem, there is no benefit to adopting this approach here, but in many practical applications the number of outputs is far less than the number of states, making the use of an output function highly beneficial.</p><pre><code class="language-julia"># Create an output component (trivial for this problem)
fin = (y1, y2)
fout = (y1, y2)
foutin = ()
fcomp = (y1, y2) -&gt; (y1, y2)
comp = ExplicitComponent(fcomp, fin, fout, foutin; deriv = ForwardFD())

mda = ExplicitComponent(isys, comp; solver=Newton())</code></pre><p>Here is the XDSM diagram of the Sellar problem after combining the implicit system of equations with the nonlinear solver to create an explicit component.</p><p><img src="../sellar-xdsm4.svg" alt/></p><h2 id="Combining-Explicit-Components-into-an-Explicit-System"><a class="docs-heading-anchor" href="#Combining-Explicit-Components-into-an-Explicit-System">Combining Explicit Components into an Explicit System</a><a id="Combining-Explicit-Components-into-an-Explicit-System-1"></a><a class="docs-heading-anchor-permalink" href="#Combining-Explicit-Components-into-an-Explicit-System" title="Permalink"></a></h2><p>Since there are no longer any model interdependencies, each component may be called sequentially to generate the final output.  We can express this sequence of explicit components as a single explicit system with its own set of inputs and outputs</p><pre><code class="language-julia"># components in the sellar problem
components_sellar = (mda, obj, c1, c2)

# inputs to the sellar problem
inputs_sellar = (x, z1, z2)

# outputs from the sellar problem
outputs_sellar = (f, g1, g2)

sellar = ExplicitSystem(components_sellar, inputs_sellar, outputs_sellar)</code></pre><p>At this point we have achieved our goal of representing the Sellar problem as an explicit one-component system.</p><p><img src="../sellar-xdsm-final.svg" alt/></p><h2 id="Querying-Explicit-Components-and/or-Systems"><a class="docs-heading-anchor" href="#Querying-Explicit-Components-and/or-Systems">Querying Explicit Components and/or Systems</a><a id="Querying-Explicit-Components-and/or-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Querying-Explicit-Components-and/or-Systems" title="Permalink"></a></h2><p>Now that our entire system has been reduced down into a single explicit component, we can easily obtain the outputs (expressed as a vector) and their derivatives (expressed as a matrix) with respect to the design variables for any set of design variables.</p><pre><code class="language-julia"># input arguments to the Sellar problem, expressed as a single vector
X = [0.29, 0.78, 0.60]

# outputs from the Sellar problem, expressed as a single vector
Y = outputs!(sellar, X)

# jacobian of the outputs with respect to the inputs, expressed as a matrix
dYdX = jacobian!(sellar, X)

# combined evaluation of outputs and jacobian
Y, dYdX = outputs_and_jacobian!(sellar, X)</code></pre><p>If the vectorized input/output format is inconvenient, CoupledSystems provides utility functions which may be used to combine inputs and/or separate outputs.</p><pre><code class="language-julia"># define inputs as variables
x_test = 0.29
z1_test = 0.78
z2_test = 0.60

# sellar problem vector input
X = combine((x_test, z1_test, z2_test))

# sellar problem vector and jacobian output
Y, dYdX = outputs_and_jacobian!(sellar, X)

# sellar problem variable outputs (in order)
f, g1, g2 = separate(outputs_sellar, Y)</code></pre><h2 id="Verifying-Derivatives"><a class="docs-heading-anchor" href="#Verifying-Derivatives">Verifying Derivatives</a><a id="Verifying-Derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Verifying-Derivatives" title="Permalink"></a></h2><p>Derivatives can be verified easily using finite differencing.</p><pre><code class="language-julia">using FiniteDiff

# Verify using forward finite differencing
f = (X) -&gt; outputs(sellar, X)
dYdX_fd = FiniteDiff.finite_difference_jacobian(f, X)
println(&quot;Maximum Error: &quot;, maximum(abs.(dYdX - dYdX_fd)))</code></pre><pre class="documenter-example-output">Maximum Error: 0.0003660497298449972</pre><p>For an even better derivative check, the jacobians can be verified against exact derivatives computed using forward mode automatic differentiation.  Note that for this use case, the <a href="https://juliadiff.org/ForwardDiff.jl/stable/user/advanced/#Fixing-NaN/Inf-Issues">NaN-safe mode of ForwardDiff</a> must be used.</p><pre><code class="language-julia">using ForwardDiff

# Verify using forward mode automatic differentiation
dYdX_ad = ForwardDiff.jacobian(f, X)
error = dYdX - dYdX_ad
println(&quot;Maximum Error: &quot;, maximum(abs.(dYdX - dYdX_ad)))</code></pre><pre class="documenter-example-output">Maximum Error: 5.292596583217346e-8</pre><p>Since this package uses analytic expressions to propagate derivatives, the derivatives computed by this package combined with finite differencing are actually more accurate than those computed using finite differencing alone.</p><pre><code class="language-julia">error = dYdX - dYdX_ad
error_fd = dYdX_fd - dYdX_ad
println(&quot;Maximum Error using Finite Differencing: &quot;,
    maximum(abs.(dYdX_fd - dYdX_ad)))
println(&quot;Maximum Error using Finite Differencing and CoupledSystems: &quot;,
    maximum(abs.(dYdX - dYdX_ad)))</code></pre><pre class="documenter-example-output">Maximum Error using Finite Differencing: 0.00036606842162290043
Maximum Error using Finite Differencing and CoupledSystems: 5.292596583217346e-8</pre><h2 id="Final-Notes"><a class="docs-heading-anchor" href="#Final-Notes">Final Notes</a><a id="Final-Notes-1"></a><a class="docs-heading-anchor-permalink" href="#Final-Notes" title="Permalink"></a></h2><p>While the intended use of CoupledSystems is typically to reduce an arbitrarily complex system down to a single explicit component, there are multiple ways in which this may be accomplished.  For example, an alternative approach to modeling the Sellar problem would be to construct a single implicit system from all components and then couple that system with a nonlinear solver.  </p><p>Additionally, there are multiple ways in which any given problem may be divided up into components.  For example, we could have defined the objective and constraint functions as a single vector-valued function rather than three.  Ultimately, while these choices may seem arbitrary, different combinations of choices may be more computationally efficient than others, especially for derivative computations.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../theory/">Theory »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 31 March 2021 23:20">Wednesday 31 March 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
