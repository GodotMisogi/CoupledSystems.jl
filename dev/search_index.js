var documenterSearchIndex = {"docs":
[{"location":"guide/#Getting-Started:-The-Sellar-Problem","page":"Getting Started","title":"Getting Started: The Sellar Problem","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The Sellar problem is is a two-discipline toy problem introduced by R.S. Sellar, S.M. Batill, and J.E. Renaud in \"Response Surface Based, Concurrent Subspace Optimization for Multidisciplinary System Design\".  The problem itself is non-physical, but it provides a simple example with which to demonstrate multidisciplinary coupling and analysis capabilities.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Each of the two disciplines in the Sellar problem consists of a single explicit equation.  The output of each discipline is used as an input to the other discipline.  Together, the two disciplines form a nonlinear system of equations which must be solved in order to obtain valid outputs.  The outputs of the coupled system of equations are used to construct objective and constraint functions for an optimization. The following is an XDSM diagram of the problem structure.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Our goal is to manipulate this problem in order to create a single explicit function/component which defines the objective and constraint values as well as their derivatives with respect to the design variables (the inputs).  In other words, we would like to take the diagram shown above and convert it to the following one-component system, and propagate derivatives while doing so.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"guide/#Defining-System-Variables","page":"Getting Started","title":"Defining System Variables","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Let's start by loading the package and defining the system variables.  This can be done with the var macro.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"using CoupledSystems\n\n# Name all variables and give them default values\n@var x = 0.0\n@var y1 = 0.0\n@var y2 = 0.0\n@var z1 = 0.0\n@var z2 = 0.0\n@var f = 0.0\n@var g1 = 0.0\n@var g2 = 0.0\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Each variable's name is used to define connections between components. The value assigned to each variable is generally used just to define the size and type of each variable, but it may also be used to generate an initial guess for a nonlinear solver.","category":"page"},{"location":"guide/#Constructing-Explicit-Components","page":"Getting Started","title":"Constructing Explicit Components","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Now that we have defined our system variables, we can use them to construct each of the components in the Sellar problem.  Since all of the components (when considered in isolation) are explicit, we model them as such.  ","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# --- Define Discipline 1 --- #\n\n# describe function inputs/outputs\nfin = (x, y2, z1, z2) # inputs\nfout = (y1,) # normal outputs\nfout_m = () # in-place (mutating) outputs\n\n# create function for discipline 1\nfunction f_d1(x, y2, z1, z2)\n    y1 = z1^2 + z2 + x - 0.2*y2\n    return y1\nend\n\n# construct explicit component for discipline 1\nd1 = ExplicitComponent(f_d1, fin, fout, fout_m; deriv=ForwardFD())\n\n# --- Define Discipline 2 --- #\n\n# describe function inputs/outputs\nfin = (y1, z1, z2) # inputs\nfout = (y2,) # normal outputs\nfout_m = () # in-place (mutating) outputs\n\n# create function for discipline 2\nfunction f_d2(y1, z1, z2)\n    y2 = sqrt(y1) + z1 + z2\n    return y2\nend\n\n# construct explicit component for discipline 2\nd2 = ExplicitComponent(f_d2, fin, fout, fout_m; deriv=ForwardFD())\n\n# --- Define Objective --- #\n\n# describe function inputs/outputs\nfin = (x, y1, y2, z1) # inputs\nfout = (f,) # normal outputs\nfout_m = () # in-place (mutating) outputs\n\n# create objective function\nfunction f_obj(x, y1, y2, z1)\n    f = x^2 + z1 + y1 + exp(-y2) # objective\n    return f\nend\n\n# construct explicit component for objective\nobj = ExplicitComponent(f_obj, fin, fout, fout_m; deriv=ForwardFD())\n\n# --- Define Constraint 1 --- #\n\n# describe function inputs/outputs\nfin = (y1,) # inputs\nfout = (g1,) # normal outputs\nfout_m = () # in-place (mutating) outputs\n\n# define first constraint function\nfunction f_c1(y1)\n    g1 = 3.16 - y1\n    return g1\nend\n\n# construct explicit component for constraint 1\nc1 = ExplicitComponent(f_c1, fin, fout, fout_m; deriv=ForwardFD())\n\n# --- Define Constraint 2 --- #\n\n# describe function inputs/outputs\nfin = (y2,) # inputs\nfout = (g2,) # normal outputs\nfout_m = () # in-place (mutating) outputs\n\n# define second constraint function\nfunction f_c2(y2)\n    g2 = y2 - 24.0\n    return g2\nend\n\n# construct explicit component for constraint 2\nc2 = ExplicitComponent(f_c2, fin, fout, fout_m; deriv=ForwardFD())\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The method by which to calculate the jacobian of each component is provided through the deriv keyword argument.  Possible jacobian calculation methods include:","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Forward Finite Differencing (ForwardFD) (default)\nCentral Finite Differencing (CentralFD())\nComplex Step Finite Differencing (ComplexFD())\nForward-Mode Automatic Differentiation (ForwardAD())\nReverse-Mode Automatic Differentiation (ReverseAD())  ","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"You can even provide your own jacobian function through the df keyword argument.","category":"page"},{"location":"guide/#Converting-Explicit-Components-into-Implicit-Components","page":"Getting Started","title":"Converting Explicit Components into Implicit Components","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We would like to be able to converge all interdependent components simultaneously.  This can be done with the help of a nonlinear solver.  Let's go ahead and add one to the XDSM diagram.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Notice that the two disciplinary components have been converted to implicit components so that they can provide residual vectors to the nonlinear solver.  The nonlinear solver then drives these residuals to zero and provides the final states/outputs y_1 and y_2 to the rest of the system.  Let's go ahead and convert our explicit components to implicit components so that they can be used to provide residual vectors (and associated derivatives) to the nonlinear solver.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# convert discipline 1 into an implicit component\nd1i = ImplicitComponent(d1)\n\n# convert discipline 2 into an implicit component\nd2i = ImplicitComponent(d2)\n\nnothing #hide","category":"page"},{"location":"guide/#Constructing-an-Implicit-System","page":"Getting Started","title":"Constructing an Implicit System","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"At this point we combine the two implicit components to create a single set of residual equations.  The state variables of the corresponding system correspond to the outputs of all of its subcomponents.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"\n# components in the implicit system\ncomponents_isys = (d1i, d2i)\n\n# inputs to the implicit system\ninputs_isys = (x, z1, z2)\n\n# outputs are the subcomponent outputs\n\n# implicit system construction\nisys = ImplicitSystem(components_isys, inputs_isys)\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"It is also possible to construct an implicit system directly from explicit components.  In this case, explicit components are converted to implicit components during construction.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"\n# components in the implicit system\ncomponents_isys = (d1, d2)\n\n# inputs to the implicit system\ninputs_isys = (x, z1, z2)\n\n# implicit system construction\nisys = ImplicitSystem(components_isys, inputs_isys)\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Let's now update the XDSM diagram to account for the newly constructed implicit system.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"guide/#Coupling-an-Implicit-Component-with-a-Solver-to-Construct-an-Explicit-Component","page":"Getting Started","title":"Coupling an Implicit Component with a Solver to Construct an Explicit Component","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Now that we have a single implicit system of equations, let's couple it with a nonlinear solver in order to solve for the outputs.  We represent the resulting component as an explicit component.  Note that the initial guess for the Newton solver corresponds to the default values of the variables y1 and y2.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"mda = ExplicitComponent(isys; solver=Newton())\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The default outputs for an implicit component/system which is converted to a explicit component are the state variables of the system.  However, it is also possible to provide only a subset of the state variables as outputs.  This has the potential to reduce computational expenses related to derivative computations.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"fout = (y1, y2)\nmda = ExplicitComponent(isys, fout; solver=Newton())\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Another option for reducing the computational expenses involved with derivative computations is to include an output function (expressed as an explicit component) when coupling an implicit system with a nonlinear solver.  An output function calculates a small number of outputs (relative to the number of state variables) from the inputs and state variables of an implicit system.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Since all state variables are outputs in this toy problem, there is no benefit to adopting this approach here, but in many practical applications the number of outputs is far less than the number of states, making the use of an output function highly beneficial.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"\n# Create an output component (trivial for this problem)\nfin = (y1, y2)\nfout = (y1, y2)\nfoutin = ()\nfcomp = (y1, y2) -> (y1, y2)\ncomp = ExplicitComponent(fcomp, fin, fout, foutin; deriv = ForwardFD())\n\nmda = ExplicitComponent(isys, comp; solver=Newton())\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Here is the XDSM diagram of the Sellar problem after combining the implicit system of equations with the nonlinear solver to create an explicit component.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"guide/#Combining-Explicit-Components-into-an-Explicit-System","page":"Getting Started","title":"Combining Explicit Components into an Explicit System","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Since there are no longer any model interdependencies, each component may be called sequentially to generate the final output.  We can express this sequence of explicit components as a single explicit system with its own set of inputs and outputs","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"\n# components in the sellar problem\ncomponents_sellar = (mda, obj, c1, c2)\n\n# inputs to the sellar problem\ninputs_sellar = (x, z1, z2)\n\n# outputs from the sellar problem\noutputs_sellar = (f, g1, g2)\n\nsellar = ExplicitSystem(components_sellar, inputs_sellar, outputs_sellar)\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"At this point we have achieved our goal of representing the Sellar problem as an explicit one-component system.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"guide/#Querying-Explicit-Components-and/or-Systems","page":"Getting Started","title":"Querying Explicit Components and/or Systems","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Now that our entire system has been reduced down into a single explicit component, we can easily obtain the outputs (expressed as a vector) and their derivatives (expressed as a matrix) with respect to the design variables for any set of design variables.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# input arguments to the Sellar problem, expressed as a single vector\nX = [0.29, 0.78, 0.60]\n\n# outputs from the Sellar problem, expressed as a single vector\nY = outputs!(sellar, X)\n\n# jacobian of the outputs with respect to the inputs, expressed as a matrix\ndYdX = jacobian!(sellar, X)\n\n# combined evaluation of outputs and jacobian\nY, dYdX = outputs_and_jacobian!(sellar, X)\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"If the vectorized input/output format is inconvenient, CoupledSystems provides utility functions which may be used to combine inputs and/or separate outputs.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# define inputs as variables\nx_test = 0.29\nz1_test = 0.78\nz2_test = 0.60\n\n# sellar problem vector input\nX = combine((x_test, z1_test, z2_test))\n\n# sellar problem vector and jacobian output\nY, dYdX = outputs_and_jacobian!(sellar, X)\n\n# sellar problem variable outputs (in order)\nf, g1, g2 = separate(outputs_sellar, Y)","category":"page"},{"location":"guide/#Verifying-Derivatives","page":"Getting Started","title":"Verifying Derivatives","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Derivatives can be verified easily using finite differencing.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"using FiniteDiff\n\n# Verify using forward finite differencing\nf = (X) -> outputs(sellar, X)\ndYdX_fd = FiniteDiff.finite_difference_jacobian(f, X)\nprintln(\"Maximum Error: \", maximum(abs.(dYdX - dYdX_fd)))\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"For an even better derivative check, the jacobians can be verified against exact derivatives computed using forward mode automatic differentiation.  Note that for this use case, the NaN-safe mode of ForwardDiff must be used.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"using ForwardDiff\n\n# Verify using forward mode automatic differentiation\ndYdX_ad = ForwardDiff.jacobian(f, X)\nerror = dYdX - dYdX_ad\nprintln(\"Maximum Error: \", maximum(abs.(dYdX - dYdX_ad)))\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"dYdX_ad = [1.4486568466809213 2.0897560103596686 0.6033081762203991; -0.9099208777535168 -1.2374923948590968 -0.7279367033191703; 0.4503956112356196 1.6125380257032502 1.3603164834112624] #hide\nerror = dYdX - dYdX_ad #hide\nprintln(\"Maximum Error: \", maximum(abs.(dYdX - dYdX_ad))) #hide\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Since this package uses analytic expressions to propagate derivatives, the derivatives computed by this package combined with finite differencing are actually more accurate than those computed using finite differencing alone.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"error = dYdX - dYdX_ad\nerror_fd = dYdX_fd - dYdX_ad\nprintln(\"Maximum Error using Finite Differencing: \",\n    maximum(abs.(dYdX_fd - dYdX_ad)))\nprintln(\"Maximum Error using Finite Differencing and CoupledSystems: \",\n    maximum(abs.(dYdX - dYdX_ad)))\nnothing #hide","category":"page"},{"location":"guide/#Final-Notes","page":"Getting Started","title":"Final Notes","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"While the intended use of CoupledSystems is typically to reduce an arbitrarily complex system down to a single explicit component, there are multiple ways in which this may be accomplished.  For example, an alternative approach to modeling the Sellar problem would be to construct a single implicit system from all components and then couple that system with a nonlinear solver.  ","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Additionally, there are multiple ways in which any given problem may be divided up into components.  For example, we could have defined the objective and constraint functions as a single vector-valued function rather than three.  Ultimately, while these choices may seem arbitrary, different combinations of choices may be more computationally efficient than others, especially for derivative computations.","category":"page"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"CoupledSystems is developed around the idea that most functions and/or system components may be modeled as either an explicit vector valued function y = f(x) or an implicit vector-valued residual function 0 = r(x y), where x is a vector which contains the inputs to a system component and y is a vector which contains the outputs from a system component.  For implicit components, valid outputs correspond to those which satisfy the vector valued residual function 0 = r(xy) for a given set of inputs x.","category":"page"},{"location":"theory/#The-Relationship-between-Explicit-and-Implicit-Components","page":"Theory","title":"The Relationship between Explicit and Implicit Components","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Explicit components may easily be converted to implicit components by subtracting the provided outputs bary from the actual outputs y = f(x), resulting in the following residual equation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"0 = r(x bary) = f(x) - bary","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Implicit components, on the other hand, may be effectively \"seen\" as explicit components once they are coupled with a solver which converges their residual equations to zero.  For example, while a computational fluid dynamics program internally solves an implicit system of equations to obtain fluid properties throughout a domain, programs which call the same CFD package effectively see the CFD package as an explicit component from which they expect to receive a converged set of outputs y given a set of inputs x.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"There is an important caveat in the effective conversion from implicit to explicit components.  While explicit components inherently contain a one-to-one mapping between inputs and outputs, the same is not true for implicit components.  Multiple sets of outputs may be able to satisfy the residual equations of an implicit component for a given set of inputs.  If a one-to-one mapping does not exist for a given implicit component, then the outputs from that component are dependent on the choice of solver and initial output guess, in addition to the inputs (if a solution exists at all!).","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: )","category":"page"},{"location":"theory/#Derivatives-of-Explicit-and-Implicit-Components","page":"Theory","title":"Derivatives of Explicit and Implicit Components","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"It is often useful to obtain the sensitivities of the outputs of a given system to its inputs.  This helps to both understand the system and inform gradient-based optimization.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The sensitivities of the outputs to the inputs for an explicit component is simply the partial derivative of the output function with respect to the inputs.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"fracdydx = fracpartial fpartial x","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The partial derivatives fracpartial fpartial x may be computed analytically, with automatic differentiation, and/or with finite differencing.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"To obtain the sensitivities of the outputs with respect to the inputs for an implicit component we first take the total derivative of the residual function with respect to the inputs.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"fracdrdx = fracpartial rpartial x + fracpartial rpartial yfracdydx","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The total derivative fracdrdx in this expression is zero since any change in the inputs for a valid set of outputs will still result in a zero-valued residual function.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"0 = fracpartial rpartial x + fracpartial rpartial yfracdydx","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We now manipulate this expression to obtain the derivative of the outputs with respect to the inputs.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"fracdydx = -left(fracpartial rpartial yright)^-1fracpartial rpartial x","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The partial derivatives fracpartial rpartial x and fracpartial rpartial y may be computed analytically, with automatic differentiation, and/or with finite differencing.  Note that the converged set of outputs y must be used when calculating the partials to obtain a valid set of derivatives.","category":"page"},{"location":"theory/#Explicit-Systems","page":"Theory","title":"Explicit Systems","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"We define an explicit system as a system containing explicit components where each component's inputs correspond to either one of the previously evaluated component's outputs or the system inputs.  An illustration of an explicit system is shown in the following diagram.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: )","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"An explicit system maps a set of inputs to a set of outputs through an explicit input-output relationship.  It may therefore be seen as a single explicit component composed of multiple explicit components.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: )","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Since there are no implicit dependencies in an explicit system, the chain rule may be used in forward or reverse mode to calculate the derivatives of the outputs with respect to the inputs.  ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The computational cost of applying the chain rule scales linearly with either the inputs or outputs depending on whether the chain rule is applied in forward or reverse mode respectively.  It is therefore advised to apply the chain rule in forward mode if the number of outputs exceeds the number of inputs and reverse mode otherwise.","category":"page"},{"location":"theory/#Implicit-Systems","page":"Theory","title":"Implicit Systems","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"We define an implicit system as a system containing implicit components where the system's residuals and outputs correspond to each of its subcomponent's residuals and outputs concatenated.  The inputs to each subcomponent may correspond to the system inputs and/or the outputs of any other subcomponent.  An illustration of an implicit system is shown in the following diagram.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: )","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Since explicit components may be easily converted to implicit components, implicit systems may be used to model any combination of explicit and implicit components.  Implicit systems may be viewed as a single implicit component with a set of residual equations and outputs corresponding to those of its subcomponents.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: )","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The partial derivatives of an implicit system with respect to its inputs and outputs may be constructed using the partial derivatives of its subcomponents with respect to their inputs and outputs.  In many cases, the resulting matrix will be sparse.","category":"page"},{"location":"theory/#Analytical-Sensitivity-Equations","page":"Theory","title":"Analytical Sensitivity Equations","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"As we have defined them, the outputs of implicit components (including implicit systems) are identical to the state variables of the system.  In many cases, however, implicit components are coupled with output equations which calculate a relatively small number of important outputs from the inputs and state variables of an implicit component.  In this case, we can apply the analytic sensitivity equations to drastically reduce the computational cost of computing the derivatives of the implicit component.  ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The cost of applying the analytic sensitivity equations scales linearly with the number of inputs or outputs in direct or adjoint mode respectively. It is therefore advised to use the direct mode of the analytic sensitivity equations when the number of outputs exceeds the number of inputs and adjoint mode otherwise.","category":"page"},{"location":"theory/#Reducing-Systems-of-Components-to-a-Single-Explicit-Component","page":"Theory","title":"Reducing Systems of Components to a Single Explicit Component","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Any system composed of explicit and implicit components may be reduced to a single explicit component.  For example, all components may be converted into implicit components, combined into a single implicit system, and then converted to an explicit component.  Alternatively, interdependent components may be combined together into implicit systems which may then be converted into explicit components and then combined with other explicit components into an explicit system.  While the result of the different approaches is the same, the computational efficiency may vary.  For example, the latter approach for combining components together is likely more computationally efficient than the former approach.   In any case, once the system has been reduced into a single explicit component using CoupledSystems, that component may be used to easily obtain outputs and derivatives of the outputs given a set of inputs.","category":"page"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages = [\"library.md\"]\nDepth = 3","category":"page"},{"location":"library/#Public-API","page":"Library","title":"Public API","text":"","category":"section"},{"location":"library/#Differentiation-Methods","page":"Library","title":"Differentiation Methods","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"AbstractDiffMethod\nAbstractAD\nForwardAD\nReverseAD\nAbstractFD\nForwardFD\nCentralFD\nComplexFD\nForward\nReverse\nDirect\nAdjoint","category":"page"},{"location":"library/#CoupledSystems.AbstractDiffMethod","page":"Library","title":"CoupledSystems.AbstractDiffMethod","text":"AbstractDiffMethod\n\nAbstract type representing different differentiation methods\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.AbstractAD","page":"Library","title":"CoupledSystems.AbstractAD","text":"AbstractAD\n\nAbstract type representing different automatic differentation methods\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.ForwardAD","page":"Library","title":"CoupledSystems.ForwardAD","text":"ForwardAD{T} <: AbstractAD\n\nForward automatic differentiation using the ForwardDiff package.\n\nFields:\n\nchunk::T: Chunk size\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.ReverseAD","page":"Library","title":"CoupledSystems.ReverseAD","text":"ReverseAD <: AbstractAD\n\nReverse automatic differentiation using the ReverseDiff package.\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.AbstractFD","page":"Library","title":"CoupledSystems.AbstractFD","text":"AbstractFD\n\nAbstract type representing different finite difference methods\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.ForwardFD","page":"Library","title":"CoupledSystems.ForwardFD","text":"ForwardFD <: AbstractFD\n\nForward finite differencing as implemented by the FiniteDiff package\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.CentralFD","page":"Library","title":"CoupledSystems.CentralFD","text":"CentralFD <: AbstractFD\n\nCentral finite differencing as implemented by the FiniteDiff package\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.ComplexFD","page":"Library","title":"CoupledSystems.ComplexFD","text":"ComplexFD <: AbstractFD\n\nComplex step finite differencing as implemented by the FiniteDiff package\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.Forward","page":"Library","title":"CoupledSystems.Forward","text":"Forward <: AbstractChainRuleMode\n\nType indicating that the chain rule should be applied in forward mode\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.Reverse","page":"Library","title":"CoupledSystems.Reverse","text":"Reverse <: AbstractChainRuleMode\n\nType indicating that the chain rule should be applied in reverse mode\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.Direct","page":"Library","title":"CoupledSystems.Direct","text":"Direct <: AbstractSensitivityMode\n\nType indicating that the analytic sensitivity equations should be applied using the direct method.\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.Adjoint","page":"Library","title":"CoupledSystems.Adjoint","text":"Adjoint <: AbstractSensitivityMode\n\nType indicating that the analytic sensitivity equations should be applied using the adjoint method.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sparsity","page":"Library","title":"Sparsity","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"AbstractSparsityPattern\nDensePattern\nSparsePattern","category":"page"},{"location":"library/#CoupledSystems.AbstractSparsityPattern","page":"Library","title":"CoupledSystems.AbstractSparsityPattern","text":"AbstractSparsityPattern\n\nAbstract type representing the sparsity pattern of a jacobian matrix\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.DensePattern","page":"Library","title":"CoupledSystems.DensePattern","text":"DensePattern <: AbstractSparsityPattern\n\nType which indicates that a jacobian is dense\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.SparsePattern","page":"Library","title":"CoupledSystems.SparsePattern","text":"SparsePattern{TI} <: AbstractSparsityPattern\n\nType which indicates that a jacobian is sparse and indicates the non-zero rows and columns\n\nFields:\n\nrows::Vector{TI}: Row of each non-zero matrix element\ncols::Vector{TI}: Column of each non-zero matrix element\n\n\n\n\n\n","category":"type"},{"location":"library/#Constructors","page":"Library","title":"Constructors","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"AbstractComponent\nAbstractExplicitComponent\nExplicitComponent\nExplicitSystem\nAbstractImplicitComponent\nImplicitComponent\nImplicitSystem","category":"page"},{"location":"library/#CoupledSystems.AbstractComponent","page":"Library","title":"CoupledSystems.AbstractComponent","text":"AbstractComponent\n\nSupertype for all components\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.AbstractExplicitComponent","page":"Library","title":"CoupledSystems.AbstractExplicitComponent","text":"AbstractExplicitComponent <: AbstractComponent\n\nSupertype for components defined by the vector valued output function y = f(x)\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.ExplicitComponent","page":"Library","title":"CoupledSystems.ExplicitComponent","text":"ExplicitComponent{TX, TY, TJ, TI, TO} <: AbstractExplicitComponent\n\nSystem component defined by the explicit vector-valued output function: y = f(x)\n\nFields\n\nf: In-place output function f(y, x)\ndf: In-place jacobian function df(dydx, x)\nfdf: In-place combined output and jacobian function fdf(y, dydx, x)\nx_f::TX: Inputs used to evaluate the outputs\nx_df::TX: Inputs used to evaluate the jacobian\ny::TY: Outputs\ndydx::TJ: Jacobian\nargin::TI: Tuple of named inputs to output function, defines size, type, and default values of inputs\nargout::TO: Tuple of named outputs from output function, defines size and type of outputs\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.ExplicitSystem","page":"Library","title":"CoupledSystems.ExplicitSystem","text":"ExplicitSystem{TC, TX, TY, TJ, TD} <: AbstractExplicitComponent\n\nExplicit system constructed from a chain of explicit system components called sequentially.\n\nFields\n\ncomponents::TC: Collection of components, in calling order\ninput_mapping::Vector{NTuple{2,Vector{Int}}}:\ncomponent_output_mapping::Vector{Vector{NTuple{2,Vector{Int}}}}:\ncomponent_input_mapping::Vector{Vector{NTuple{2,Int}}}:\noutput_mapping::Vector{NTuple{2,Int}}:\nx_f::TX: Inputs used to evaluate the system outputs\nx_df::TX: Inputs used to evaluate the system jacobian\ny::TY: Storage for the system outputs\ndydx::TJ: Storage for the system jacobian\nargin::TI: Tuple of named inputs to output function, defines size, type, and default values of inputs\nargout::TO: Tuple of named outputs from output function, defines size and type of outputs\nmode::TD: Default direction in which to apply the chain rule (Forward() or Reverse())\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.AbstractImplicitComponent","page":"Library","title":"CoupledSystems.AbstractImplicitComponent","text":"AbstractImplicitComponent <: AbstractComponent\n\nSupertype for components defined by the vector valued residual function 0 = f(x, y)\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.ImplicitComponent","page":"Library","title":"CoupledSystems.ImplicitComponent","text":"ImplicitComponent{TX, TY, TR, TDRX, TDRY, TI, TO} <: AbstractImplicitComponent\n\nSystem component defined by the vector-valued residual function: 0 = f(x, y)\n\nFields\n\nf: In-place residual function f(r, x, y).\ndfdx: In-place residual jacobian function with respect to the inputs dfdx(drdx, x, y)\ndfdy: In-place residual jacobian function with respect to the outputs dfdy(drdy, x, y)\nfdfdx: In-place combined residual and jacobian with respect to the inputs function fdfdx(r, drdx, x, y).\nfdfdy: In-place combined residual and jacobian with respect to the outputs function fdfdy(r, drdy, x, y).\nfdf: In-place combined residual and jacobians function fdf(r, drdx, drdy, x, y).\nx_f::TX: x used to evaluate f\ny_f::TY: y used to evaluate f\nx_dfdx::TX: x used to evaluate dfdx\ny_dfdx::TY: y used to evaluate dfdx\nx_dfdy::TX: x used to evaluate dfdy\ny_dfdy::TY: y used to evaluate dfdy\nr::TR: cache for residual`\ndrdx::TDRX: cache for residual jacobian with respect to x\ndrdy::TDRY: cache for residual jacobian with respect to y\nargin::TI: Tuple of named inputs to output function, defines size, type, and default values of inputs\nargout::TO: Tuple of named outputs from output function, defines size, type, and default values of outputs\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.ImplicitSystem","page":"Library","title":"CoupledSystems.ImplicitSystem","text":"ImplicitSystem{TC, TX, TY, TR, TDRX, TDRY, TI, TO} <: AbstractImplicitComponent\n\nImplicit system constructed from interdependent explicit and/or implicit system components.\n\nFields\n\ncomponents::TC: Collection of components, in preferred calling order\ncomponent_input_mapping::Vector{Vector{NTuple{2,Int}}}:\nx_f::TX: x used to evaluate f\ny_f::TY: y used to evaluate f\nx_dfdx::TX: x used to evaluate dfdx\ny_dfdx::TY: y used to evaluate dfdx\nx_dfdy::TX: x used to evaluate dfdy\ny_dfdy::TY: y used to evaluate dfdy\nr::TR: cache for residual`\ndrdx::TDRX: cache for residual jacobian with respect to x\ndrdy::TDRY: cache for residual jacobian with respect to y\nargin::TI: Tuple of named inputs to output function, defines size, type, and default values of inputs\nargout::TO: Tuple of named outputs from output function, defines size, type, and default values of outputs\nidx::Vector{Int}: Index used for accessing outputs/residuals for each component\n\n\n\n\n\n","category":"type"},{"location":"library/#Solvers","page":"Library","title":"Solvers","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"AbstractSolver\nNewton","category":"page"},{"location":"library/#CoupledSystems.AbstractSolver","page":"Library","title":"CoupledSystems.AbstractSolver","text":"AbstractSolver\n\nSupertype for solvers that may be used to solve implicit systems of equations.\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.Newton","page":"Library","title":"CoupledSystems.Newton","text":"Newton{T} <: AbstractSolver\n\nNewton solver, as provided by the NLsolve package.  Stores the keyword arguments which are passed to NLsolve in the field kwargs\n\n\n\n\n\n","category":"type"},{"location":"library/#Calling-Interface","page":"Library","title":"Calling Interface","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"outputs\noutputs!\noutputs!!\noutputs!!!\njacobian\njacobian!\njacobian!!\njacobian!!!\noutputs_and_jacobian\noutputs_and_jacobian!\noutputs_and_jacobian!!\noutputs_and_jacobian!!!\nresiduals\nresiduals!\nresiduals!!\nresiduals!!!\nresidual_input_jacobian\nresidual_input_jacobian!\nresidual_input_jacobian!!\nresidual_input_jacobian!!!\nresidual_output_jacobian\nresidual_output_jacobian!\nresidual_output_jacobian!!\nresidual_output_jacobian!!!\nresiduals_and_input_jacobian\nresiduals_and_input_jacobian!\nresiduals_and_input_jacobian!!\nresiduals_and_input_jacobian!!!\nresiduals_and_output_jacobian\nresiduals_and_output_jacobian!\nresiduals_and_output_jacobian!!\nresiduals_and_output_jacobian!!!\nresiduals_and_jacobians\nresiduals_and_jacobians!\nresiduals_and_jacobians!!\nresiduals_and_jacobians!!!","category":"page"},{"location":"library/#CoupledSystems.outputs","page":"Library","title":"CoupledSystems.outputs","text":"outputs(component::AbstractComponent)\n\nReturn the outputs stored in component.\n\n\n\n\n\noutputs(component::AbstractExplicitComponent, x)\n\nEvaluate the outputs of an explicit system component.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.outputs!","page":"Library","title":"CoupledSystems.outputs!","text":"outputs!(component::AbstractExplicitComponent, y, x)\n\nEvaluate the outputs of an explicit system component and store the result in y.\n\nThis does not update any of the values stored in component\n\n\n\n\n\noutputs!(component::ExplicitSystem, y, xsub, ysub, x)\n\nEvaluate the outputs of an explicit system and store the result in y. Store the intermediate results in xsub and ysub.\n\nThis does not update any of the values stored in component\n\n\n\n\n\noutputs!(component::AbstractExplicitComponent, x)\n\nEvaluate the outputs of an explicit system component.\n\nReturn the result and store in component.y.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.outputs!!","page":"Library","title":"CoupledSystems.outputs!!","text":"outputs!!(component::AbstractExplicitComponent, x)\n\nForce (re-)evaluation of the outputs of an explicit system component.\n\nReturn the result and store in component.y.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.outputs!!!","page":"Library","title":"CoupledSystems.outputs!!!","text":"outputs!!!(component::AbstractExplicitComponent, x)\n\nForce (re-)evaluation of the outputs of an explicit system component. Also force (re-)evaluation of the outputs of the system's subcomponents.\n\nReturn the result and store in component.y.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.jacobian","page":"Library","title":"CoupledSystems.jacobian","text":"jacobian(component::AbstractExplicitComponent)\n\nReturn the jacobian of the outputs with respect to the inputs stored in component\n\n\n\n\n\njacobian(component::AbstractExplicitComponent, x)\n\nEvaluate the jacobian of the outputs with respect to the inputs.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.jacobian!","page":"Library","title":"CoupledSystems.jacobian!","text":"jacobian!(component::AbstractExplicitComponent, dydx, x)\n\nEvaluate the jacobian of the outputs with respect to the inputs and store the result in dydx\n\nThis does not update any of the values stored in component\n\n\n\n\n\njacobian!(component::ExplicitSystem, dydx, xsub, ysub, dsub, x, mode=component.mode)\n\nEvaluate the jacobian of the outputs with respect to the inputs and store the result in dydx.  Store the intermediate subcomponent x, y and dydx values in xsub, ysub, and dsub respectively.\n\nThis does not update any of the values stored in component\n\n\n\n\n\njacobian!(component::AbstractExplicitComponent, x)\n\nEvaluate the jacobian of the outputs with respect to the inputs.\n\nReturn the result and store in component.dydx.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.jacobian!!","page":"Library","title":"CoupledSystems.jacobian!!","text":"jacobian!!(component::AbstractExplicitComponent, x)\n\nForce (re-)evaluation of the jacobian of the outputs with respect to the inputs.\n\nReturn the result and store in component.dydx.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.jacobian!!!","page":"Library","title":"CoupledSystems.jacobian!!!","text":"jacobian!!!(component::AbstractExplicitComponent, x)\n\nForce (re-)evaluation of the jacobian of the outputs with respect to the inputs. Also force (re-)evaluation of the jacobians of the system's subcomponents.\n\nReturn the result and store in component.dydx.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.outputs_and_jacobian","page":"Library","title":"CoupledSystems.outputs_and_jacobian","text":"outputs_and_jacobian(component::AbstractExplicitComponent)\n\nReturn the outputs and their derivatives with respect to the inputs stored in component.\n\n\n\n\n\noutputs_and_jacobian(component::AbstractExplicitComponent, x)\n\nEvaluate the outputs and their derivatives with respect to the inputs.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.outputs_and_jacobian!","page":"Library","title":"CoupledSystems.outputs_and_jacobian!","text":"outputs_and_jacobian!(component::AbstractExplicitComponent, y, dydx, x)\n\nEvaluate the outputs and their derivatives with respect to the inputs and store the results in y and dydx\n\nThis does not update any of the values stored in component\n\n\n\n\n\noutputs_and_jacobian!(component::ExplicitSystem, y, dydx, xsub, ysub, dsub,\n    x, mode=component.mode)\n\nEvaluate the outputs and their derivatives with respect to the inputs and store the results in y and dydx.  Store the intermediate subcomponent x, y and dydx values in xsub, ysub, and dsub respectively.\n\nThis does not update any of the values stored in component\n\n\n\n\n\noutputs_and_jacobian!(component::AbstractExplicitComponent, x)\n\nEvaluate the outputs and their derivatives with respect to the inputs.\n\nReturn the result and store in component.y and component.dydx\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.outputs_and_jacobian!!","page":"Library","title":"CoupledSystems.outputs_and_jacobian!!","text":"outputs_and_jacobian!!(component::AbstractExplicitComponent, x)\n\nForce (re-)evaluation of the outputs and their derivatives with respect to the inputs.\n\nReturn the result and store in component.y and component.dydx\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.outputs_and_jacobian!!!","page":"Library","title":"CoupledSystems.outputs_and_jacobian!!!","text":"outputs_and_jacobian!!!(component::AbstractExplicitComponent, x)\n\nForce (re-)evaluation of the outputs and their derivatives with respect to the inputs for the system.  Also force (re-)evaluation of the outputs and jacobians of the system's subcomponents.\n\nReturn the result and store in component.y and component.dydx\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals","page":"Library","title":"CoupledSystems.residuals","text":"residuals(component::AbstractImplicitComponent)\n\nReturn the residuals stored in component\n\n\n\n\n\nresiduals(component::AbstractImplicitComponent, x, y)\n\nEvaluate the residuals of an implicit system component.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals!","page":"Library","title":"CoupledSystems.residuals!","text":"residuals!(component::AbstractImplicitComponent, r, x, y)\n\nEvaluate the residuals of an implicit system component and store the result in r.\n\nThis does not update any of the values stored in component\n\n\n\n\n\nresiduals!(component::ImplicitSystem, r, xsub, ysub, rsub, x, y)\n\nEvaluate the residuals of an implicit system and store the result in y. Store the intermediate results in xsub, ysub, and rsub.\n\nThis does not update any of the values stored in component\n\n\n\n\n\nresiduals!(component::AbstractImplicitComponent, x, y)\n\nEvaluate the residuals of an implicit system component.\n\nReturn the result and store in component.r\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals!!","page":"Library","title":"CoupledSystems.residuals!!","text":"residuals!!(component::AbstractImplicitComponent, x, y)\n\nForce (re-)evaluation of the residuals of an implicit system component.\n\nReturn the result and store in component.r\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals!!!","page":"Library","title":"CoupledSystems.residuals!!!","text":"residuals!!!(component::AbstractImplicitComponent, x, y)\n\nForce (re-)evaluation of the residuals of an implicit system component. Also force (re-)evaluation of the residuals of the system's subcomponents.\n\nReturn the result and store in component.r\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residual_input_jacobian","page":"Library","title":"CoupledSystems.residual_input_jacobian","text":"residual_input_jacobian(component::AbstractImplicitComponent)\n\nReturn the jacobian of the residuals with respect to the inputs stored in component.\n\n\n\n\n\nresidual_input_jacobian(component::AbstractImplicitComponent, x, y)\n\nEvaluate the jacobian of the residuals with respect to the inputs,\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residual_input_jacobian!","page":"Library","title":"CoupledSystems.residual_input_jacobian!","text":"residual_input_jacobian!(component::ImplicitComponent, drdx, x, y)\n\nEvaluate the jacobian of the residuals with respect to the inputs and store the result in drdx.\n\nThis does not update any of the values stored in component\n\n\n\n\n\nresidual_input_jacobian!(component::ImplicitSystem, drdx, xsub, ysub, rsub,\n    dsub, x, y)\n\nEvaluate the jacobian of the residual with respect to the inputs and store the result in drdx.  Store the intermediate subcomponent x, y and drdx values in xsub, ysub, and dsub respectively.\n\nThis does not update any of the values stored in component\n\n\n\n\n\nresidual_input_jacobian!(component::AbstractImplicitComponent, x, y)\n\nEvaluate the jacobian of the residuals with respect to the inputs.\n\nReturn the result and store in component.drdx\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residual_input_jacobian!!","page":"Library","title":"CoupledSystems.residual_input_jacobian!!","text":"residual_input_jacobian!!(component::ImplicitComponent, x, y)\n\nForce (re-)evaluation of the jacobian of the residuals with respect to the inputs.\n\nReturn the result and store in component.drdx\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residual_input_jacobian!!!","page":"Library","title":"CoupledSystems.residual_input_jacobian!!!","text":"residual_input_jacobian!!!(component::AbstractImplicitComponent, x, y)\n\nForce (re-)evaluation of the jacobian of the residuals with respect to the inputs. Also force (re-)evaluation of the jacobians of the system's subcomponents.\n\nReturn the result and store in component.drdx\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residual_output_jacobian","page":"Library","title":"CoupledSystems.residual_output_jacobian","text":"residual_output_jacobian(component::AbstractImplicitComponent)\n\nReturn the jacobian of the residuals with respect to the outputs stored in component.\n\n\n\n\n\nresidual_output_jacobian(component::AbstractImplicitComponent, x, y)\n\nEvaluate the jacobian of the residuals with respect to the outputs,\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residual_output_jacobian!","page":"Library","title":"CoupledSystems.residual_output_jacobian!","text":"residual_output_jacobian!(component::AbstractImplicitComponent, drdy, x, y)\n\nEvaluate the jacobian of the residuals with respect to the outputs and store the result in drdy\n\nThis does not update any of the values stored in component\n\n\n\n\n\nresidual_output_jacobian!(component::ImplicitSystem, drdy, xsub, ysub, dxsub,\n    dysub, x, y)\n\nEvaluate the jacobian of the residuals with respect to the outputs and store the result in drdx.  Store the intermediate subcomponent x, y and drdy values in xsub, ysub, and dsub respectively.\n\nThis does not update any of the values stored in component\n\n\n\n\n\nresidual_output_jacobian!(component::AbstractImplicitComponent, x, y)\n\nEvaluate the jacobian of the residuals with respect to the outputs.\n\nReturn the result and store in component.drdy\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residual_output_jacobian!!","page":"Library","title":"CoupledSystems.residual_output_jacobian!!","text":"residual_output_jacobian!!(component::AbstractImplicitComponent, x, y)\n\nForce (re-)evaluation of the jacobian of the residuals with respect to the outputs.\n\nReturn the result and store in component.drdy\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residual_output_jacobian!!!","page":"Library","title":"CoupledSystems.residual_output_jacobian!!!","text":"residual_output_jacobian!!!(component::AbstractImplicitComponent, x, y)\n\nForce (re-)evaluation of the jacobian of the residuals with respect to the outputs. Also force (re-)evaluation of the jacobians of the system's subcomponents.\n\nReturn the result and store in component.drdy\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals_and_input_jacobian","page":"Library","title":"CoupledSystems.residuals_and_input_jacobian","text":"residuals_and_input_jacobian(component::AbstractImplicitComponent)\n\nReturn the residual and jacobian of the residuals with respect to the inputs stored in component.\n\n\n\n\n\nresiduals_and_input_jacobian(component::AbstractImplicitComponent, x, y)\n\nEvaluate the residual and jacobian of the residuals with respect to the inputs.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals_and_input_jacobian!","page":"Library","title":"CoupledSystems.residuals_and_input_jacobian!","text":"residuals_and_input_jacobian!(component::AbstractImplicitComponent, r, drdx, x, y)\n\nEvaluate the residual and jacobian of the residuals with respect to the inputs and store the result in r and drdx.\n\nThis does not update any of the values stored in component\n\n\n\n\n\nresiduals_and_input_jacobian!(component::ImplicitSystem, r, drdx, xsub,\n    ysub, rsub, dsub, x, y)\n\nEvaluate the residuals and their derivatives with respect to the inputs and store the results in r and drdx.  Store the intermediate subcomponent x, y, r, and drdx values in xsub, ysub, rsub, and dsub respectively.\n\nThis does not update any of the values stored in component\n\n\n\n\n\nresiduals_and_input_jacobian!(component::AbstractImplicitComponent, x, y)\n\nEvaluate the residual and jacobian of the residuals with respect to the inputs.\n\nReturn the result and store in component.r and component.drdx\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals_and_input_jacobian!!","page":"Library","title":"CoupledSystems.residuals_and_input_jacobian!!","text":"residuals_and_input_jacobian!!(component::AbstractImplicitComponent, x, y)\n\nForce (re-)evaluation of the residual and jacobian of the residuals with respect to the inputs.\n\nReturn the result and store in component.r and component.drdx\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals_and_input_jacobian!!!","page":"Library","title":"CoupledSystems.residuals_and_input_jacobian!!!","text":"residuals_and_input_jacobian!!!(component::AbstractImplicitComponent, x, y)\n\nForce (re-)evaluation of the residual and jacobian of the residuals with respect to the inputs. Also force (re-)evaluation of each subcomponents residual and jacobian with respect to its inputs.\n\nReturn the result and store in component.r and component.drdx\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals_and_output_jacobian","page":"Library","title":"CoupledSystems.residuals_and_output_jacobian","text":"residuals_and_output_jacobian(component::AbstractImplicitComponent)\n\nReturn the residuals and jacobian of the residuals with respect to the outputs stored in component.\n\n\n\n\n\nresiduals_and_output_jacobian(component::AbstractImplicitComponent, x, y)\n\nEvaluate the residuals and jacobian of the residuals with respect to the outputs.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals_and_output_jacobian!","page":"Library","title":"CoupledSystems.residuals_and_output_jacobian!","text":"residuals_and_output_jacobian!(component::AbstractImplicitComponent, r, drdy, x, y)\n\nEvaluate the residuals and jacobian of the residuals with respect to the outputs and store the results in r and drdy\n\nThis does not update any of the values stored in component\n\n\n\n\n\nresiduals_and_output_jacobian!(component::ImplicitSystem, r, drdy, xsub,\n    ysub, rsub, dxsub, dysub, x, y)\n\nEvaluate the residuals and their derivatives with respect to the outputs and store the results in r and drdy.  Store the intermediate subcomponent x, y, r, drdx, and drdy values in xsub, ysub, rsub, dxsub, and dysub respectively.\n\nThis does not update any of the values stored in component\n\n\n\n\n\nresiduals_and_output_jacobian!(component::AbstractImplicitComponent, x, y)\n\nEvaluate the residuals and jacobian of the residuals with respect to the outputs.\n\nReturn the result and store in component.r and component.drdy\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals_and_output_jacobian!!","page":"Library","title":"CoupledSystems.residuals_and_output_jacobian!!","text":"residuals_and_output_jacobian!!(component::AbstractImplicitComponent, x, y)\n\nForce (re-)evaluation of the residuals and jacobian of the residuals with respect to the outputs.\n\nReturn the result and store in component.r and component.drdy\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals_and_output_jacobian!!!","page":"Library","title":"CoupledSystems.residuals_and_output_jacobian!!!","text":"residuals_and_output_jacobian!!!(component::AbstractImplicitComponent, x, y)\n\nForce (re-)evaluation of the residual and jacobian of the residuals with respect to the outputs. Also force (re-)evaluation of each subcomponents residual and jacobian with respect to its outputs.\n\nReturn the result and store in component.r and component.drdy\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals_and_jacobians","page":"Library","title":"CoupledSystems.residuals_and_jacobians","text":"residuals_and_jacobians(component::AbstractImplicitComponent)\n\nReturn the residual, its jacobian with respect to the inputs, and its jacobian with respect to the outputs stored in component.\n\n\n\n\n\nresiduals_and_jacobians(component::AbstractImplicitComponent, x, y)\n\nEvaluate the residual, its jacobian with respect to the inputs, and its jacobian with respect to the outputs.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals_and_jacobians!","page":"Library","title":"CoupledSystems.residuals_and_jacobians!","text":"residuals_and_jacobians!(component::AbstractImplicitComponent, r, drdx, drdy, x, y)\n\nEvaluate the residual, its jacobian with respect to the inputs, and its jacobian with respect to the outputs and store the results in r, drdx, and drdy\n\nThis does not update any of the values stored in component\n\n\n\n\n\nresiduals_and_jacobians!(component::ImplicitSystem, r, drdx, drdy, xsub,\n    ysub, rsub, dxsub, dysub, x, y)\n\nEvaluate the residual, its jacobian with respect to the inputs, and its jacobian with respect to the outputs and store the results in r, drdx, and drdy Store the intermediate subcomponent x, y, r, drdx, and drdy values in xsub, ysub, rsub, dxsub, and dysub respectively.\n\nThis does not update any of the values stored in component\n\n\n\n\n\nresiduals_and_jacobians!(component::AbstractImplicitComponent, x, y)\n\nEvaluate the residual, its jacobian with respect to the inputs, and its jacobian with respect to the outputs.\n\nReturn the result and store in component.r, component.drdx, and component.drdy.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals_and_jacobians!!","page":"Library","title":"CoupledSystems.residuals_and_jacobians!!","text":"residuals_and_jacobians!!(component::AbstractImplicitComponent, x, y)\n\nForce (re-)evaluation of the residual, its jacobian with respect to the inputs, and its jacobian with respect to the outputs.\n\nReturn the result and store in component.r, component.drdx, and component.drdy.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals_and_jacobians!!!","page":"Library","title":"CoupledSystems.residuals_and_jacobians!!!","text":"residuals_and_jacobians!!!(component::AbstractImplicitComponent, x, y)\n\nForce (re-)evaluation of the residual, its jacobian with respect to the inputs, and its jacobian with respect to the outputs. Also force (re-)evaluation of each subcomponents residual and jacobians.\n\nReturn the result and store in component.r, component.drdx, and component.drdy.\n\n\n\n\n\n","category":"function"},{"location":"library/#Private-API","page":"Library","title":"Private API","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [CoupledSystems]\nPublic = false\n``\n\n## Index\n","category":"page"},{"location":"library/#CoupledSystems.AbstractChainRuleMode","page":"Library","title":"CoupledSystems.AbstractChainRuleMode","text":"AbstractChainRuleMode\n\nType representing direction in which to to apply the chain rule when computing the derivatives of an explicit system.\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.AbstractSensitivityMode","page":"Library","title":"CoupledSystems.AbstractSensitivityMode","text":"AbstractSensitivityMode\n\nAbstract type representing mode by which to apply the analytic sensitivity equations when computing derivatives of an explicit component created by combining an implicit component, output component, and solver.\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.TrustRegion","page":"Library","title":"CoupledSystems.TrustRegion","text":"TrustRegion{T} <: AbstractSolver\n\nTrust region solver, as provided by the NLsolve package.  Stores the keyword arguments which are passed to NLsolve in the field kwargs\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.TrustRegion-Tuple{}","page":"Library","title":"CoupledSystems.TrustRegion","text":"TrustRegion(; kwargs...)\n\nTrust region solver, as provided by the NLsolve package.  Uses the same default arguments as NLsolve.\n\nThe relevant keyword arguments and their default values are repeated here for convenience.\n\nKeyword Arguments\n\nxtol = 0.0: Step size tolerance for ending iterations\nftol = 1e-8: Function tolerance for ending iterations\niterations = 1000: Maximum number of iterations\nfactor = 1.0: Factor for determining initial size of trust region\nautoscale = true: Autoscale variables?\nlinsolve = (x, A, b) -> copyto!(x, A\b): Linear solver function\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.axes-Tuple{NamedVar}","page":"Library","title":"Base.axes","text":"axes(var::NamedVar)\n\nReturn the axes of a named variable\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.length-Tuple{NamedVar}","page":"Library","title":"Base.length","text":"length(var::NamedVar)\n\nReturn the length of a named variable\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.size-Tuple{NamedVar}","page":"Library","title":"Base.size","text":"size(var)\n\nReturn the size of a named variable\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.allocate_jacobian","page":"Library","title":"CoupledSystems.allocate_jacobian","text":"allocate_jacobian(x, y, sparsity=DensePattern())\n\nAllocates a jacobian matrix given the inputs, outputs, and (optionally) the sparsity structure.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.analytic_sensitivity_equation","page":"Library","title":"CoupledSystems.analytic_sensitivity_equation","text":"analytic_sensitivity_equation(dfdx, dfdu, drdx, drdu, mode)\n\nCompute the sensitivities of an implicit system using the analytic sensitivity equation in Direct() or Adjoint() mode.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.combine!","page":"Library","title":"CoupledSystems.combine!","text":"combine!(y, vars::Tuple)\n\nIn-place version of combine\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.create_mutating_solver_cache-Tuple{AbstractImplicitComponent,Any,AbstractSolver}","page":"Library","title":"CoupledSystems.create_mutating_solver_cache","text":"create_mutating_solver_cache(component::AbstractImplicitComponent, x, solver::AbstractSolver)\n\nConstruct a cache for a nonlinear solver which uses mutating functions.  x is a pointer to an array that will be modified to contain the correct input values.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.create_nonmutating_solver_cache-Tuple{AbstractImplicitComponent,Any,AbstractSolver}","page":"Library","title":"CoupledSystems.create_nonmutating_solver_cache","text":"create_nonmutating_solver_cache(component::AbstractImplicitComponent, x, solver::AbstractSolver)\n\nConstruct a cache for a nonlinear solver which uses nonmutating functions.  x is a pointer to an array that will be modified to contain the correct input values.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.create_output_jacobian_functions","page":"Library","title":"CoupledSystems.create_output_jacobian_functions","text":"create_output_jacobian_functions(f!, x0, y0, dtype, sp)\n\nCreates functions to compute the jacobian using the specified derivative type and sparsity pattern.\n\nArguments\n\nf!: In-place version of the output function: y = f(x)\nx0::AbstractVector: Initial values for inputs (used for size and type information)\ny0::AbstractVector: Initial values for outputs (used for size and type information)\ndtype::AbstractDiffMethod: Method used to calculate derivatives\nsparsity::AbstractSparsityPattern: Jacobian sparsity structure\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.create_residual_input_jacobian_functions","page":"Library","title":"CoupledSystems.create_residual_input_jacobian_functions","text":"create_residual_input_jacobian_functions(f!, x0, y0, r0, dtype, sp)\n\nCreates functions to compute the jacobian of the residual with respect to the inputs using the specified derivative type and sparsity pattern.\n\nArguments\n\nf!: In-place residual function f(r, x, y).\nx0: Initial values for inputs (used for size and type information)\ny0: Initial values for outputs (used for size and type information)\nr0: Initial values for residuals (used for size and type information)\ndtype: Method to use to calculate derivatives\nsparsity: Jacobian sparsity structure\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.create_residual_output_jacobian_functions","page":"Library","title":"CoupledSystems.create_residual_output_jacobian_functions","text":"create_residual_output_jacobian_functions(f!, x0, y0, r0, dtype, sp)\n\nCreates functions to compute the jacobian of the residual with respect to the inputs using the specified derivative type and sparsity pattern.\n\nArguments\n\nf!: In-place residual function f(r, x, y).\nx0: Initial values for inputs (used for size and type information)\ny0: Initial values for outputs (used for size and type information)\nr0: Initial values for residuals (used for size and type information)\ndtype: Method to use to calculate derivatives\nsparsity: Jacobian sparsity structure\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.finitediff_type","page":"Library","title":"CoupledSystems.finitediff_type","text":"finitediff_type(mode::AbstractFD)\n\nConverts the types used by this package to the inputs expected by the FiniteDiff package.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.forward_mode_jacobian!","page":"Library","title":"CoupledSystems.forward_mode_jacobian!","text":"forward_mode_jacobian!(component::ExplicitSystem, dydx, dsub=nothing)\n\nFills in the system jacobian matrix dydx using the chain rule in forward mode.\n\nIf dsub is not provided, jacobian matrices will be taken from each subcomponent's internal storage.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.forward_mode_jacobian_branch!","page":"Library","title":"CoupledSystems.forward_mode_jacobian_branch!","text":"forward_mode_jacobian_branch!(system, dydx, ix, cprod, jc, jx, dsub=nothing)\n\nAdds to the jacobian matrix using the chain rule in forward mode.\n\nThis function is called recursively to create new branches as necessary.\n\nIf dsub is not provided, jacobian matrices will be taken from each subcomponent's internal storage.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.forward_mode_mapping-NTuple{4,Any}","page":"Library","title":"CoupledSystems.forward_mode_mapping","text":"forward_mode_mapping(inputs, components, component_input_mapping, output_mapping)\n\nReturns (input_mapping, component_output_mapping) where input_mapping contains a mapping from each system input to component inputs and/or system outputs and reversed_component_mapping contains a mapping from each component output to corresponding component inputs and/or system outputs.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.getindices-Tuple{Any,Tuple}","page":"Library","title":"CoupledSystems.getindices","text":"getindices(collection, indices::Tuple)\n\nCustom version of getindex that allow collections to be accessed using a tuple of indices\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.getsparsity-Tuple{DensePattern,Any,Any}","page":"Library","title":"CoupledSystems.getsparsity","text":"getsparsity(::DensePattern, nx, nf)\n\nGet rows and cols for dense jacobian\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.getsparsity-Tuple{SparsePattern,Any,Any}","page":"Library","title":"CoupledSystems.getsparsity","text":"getsparsity(sp::SparsePattern, nx, nf)\n\nGet rows and cols for sparse jacobian\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.inputs-Tuple{AbstractComponent}","page":"Library","title":"CoupledSystems.inputs","text":"inputs(component::AbstractComponent)\n\nReturn the inputs corresponding to the outputs stored in component\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.output_mapping_matrices-Tuple{Any,Any,Any}","page":"Library","title":"CoupledSystems.output_mapping_matrices","text":"output_mapping_matrices(argin, argstate, argout)\n\nConstruct matrices that maps an implicit function's inputs and/or state variables to specified output variables.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.reverse_mode_jacobian!","page":"Library","title":"CoupledSystems.reverse_mode_jacobian!","text":"reverse_mode_jacobian!(component::ExplicitSystem, dydx, dsub=nothing)\n\nFills in the system jacobian matrix dydx using the chain rule in reverse mode.\n\nIf dsub is not provided, jacobian matrices will be taken from each subcomponent's internal storage.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.reverse_mode_jacobian_branch!","page":"Library","title":"CoupledSystems.reverse_mode_jacobian_branch!","text":"reverse_mode_jacobian_branch!(component::ExplicitSystem, dydx, iy, cprod, jc,\n    jy, dsub=nothing)\n\nAdds to the jacobian matrix using the chain rule in reverse mode.\n\nThis function is called recursively to create new branches as necessary.\n\nIf dsub is not provided, jacobian matrices will be taken from each subcomponent's internal storage.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.same_axes","page":"Library","title":"CoupledSystems.same_axes","text":"same_axes(v1, v2)\n\nReturn v2 with axes correponding to v1.  If v1 is a scalar, return a scalar.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.setindices-Tuple{Any,Tuple,Tuple}","page":"Library","title":"CoupledSystems.setindices","text":"setindices(x, v::Tuple, indices::Tuple)\n\nCreates a new collection similar to x with the values at the indices in indices set to the values in v.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_input_jacobians!!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_input_jacobians!!","text":"subcomponent_input_jacobians!!(component::ImplicitSystem, x, y)\n\nForce (re-)evaluation the input jacobians of an implicit system's subcomponents.\n\nStore in the x_dfdx, y_dfdx, and drdx fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_input_jacobians!-Tuple{ImplicitSystem,Any,Any,Any,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_input_jacobians!","text":"subcomponent_input_jacobians!(component::ImplicitSystem, xsub, ysub, dsub, x, y)\n\nEvaluate the input jacobians of an implicit system's subcomponents. Store the results in xsub, ysub, and dsub.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_input_jacobians!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_input_jacobians!","text":"subcomponent_input_jacobians!(component::ImplicitSystem, x, y)\n\nEvaluate the input jacobians of an implicit system's subcomponents.\n\nStore in the x_dfdx, y_dfdx, and drdx fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_output_jacobians!!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_output_jacobians!!","text":"subcomponent_output_jacobians!!(component::ImplicitSystem, x, y)\n\nForce (re-)evaluation the output jacobians of an implicit system's subcomponents.\n\nStore in the x_dfdy, y_dfdy, and drdy fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_output_jacobians!-Tuple{ImplicitSystem,Any,Any,Any,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_output_jacobians!","text":"subcomponent_output_jacobians!(component::ImplicitSystem, xsub, ysub, dsub, x, y)\n\nEvaluate the output jacobians of an implicit system's subcomponents. Store the results in xsub, ysub, and dsub.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_output_jacobians!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_output_jacobians!","text":"subcomponent_output_jacobians!(component::ImplicitSystem, x, y)\n\nEvaluate the output jacobians of an implicit system's subcomponents.\n\nStore in the x_dfdy, y_dfdy, and drdy fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_outputs!!-Tuple{Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_outputs!!","text":"subcomponent_outputs!!(component::ExplicitSystem, x)\n\nForce re-evaluation of the inputs and outputs of an explicit system's subcomponents.\n\nStore in the x_f and y fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_outputs!-NTuple{4,Any}","page":"Library","title":"CoupledSystems.subcomponent_outputs!","text":"subcomponent_outputs!(component::ExplicitSystem, xsub, ysub, x)\n\nEvaluate the inputs and outputs of an explicit systems subcomponents and store the results in xsub and ysub.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_outputs!-Tuple{Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_outputs!","text":"subcomponent_outputs!(component::ExplicitSystem, x)\n\nEvaluate the inputs and outputs of an explicit system's subcomponents.\n\nStore in the x_f and y fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_outputs_and_jacobians!!-Tuple{ExplicitSystem,Any}","page":"Library","title":"CoupledSystems.subcomponent_outputs_and_jacobians!!","text":"subcomponent_outputs_and_jacobians!!(component::ExplicitSystem, x)\n\nForce (re-)evaluation of inputs, outputs, and jacobians of an explicit system's subcomponents.\n\nStore in the x_f, y, and dydx fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_outputs_and_jacobians!-Tuple{ExplicitSystem,Any,Any,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_outputs_and_jacobians!","text":"subcomponent_outputs_and_jacobians!(component::ExplicitSystem, xsub, ysub, dsub, x)\n\nEvaluate the inputs, outputs, and jacobians of an explicit system's subcomponents. Store the results in xsub, ysub, and dsub.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_outputs_and_jacobians!-Tuple{ExplicitSystem,Any}","page":"Library","title":"CoupledSystems.subcomponent_outputs_and_jacobians!","text":"subcomponent_outputs_and_jacobians!(component::ExplicitSystem, x)\n\nEvaluate the inputs, outputs, and jacobians of an explicit system's subcomponents.\n\nStore in the x_f, y, and dydx fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_residuals!!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_residuals!!","text":"subcomponent_residuals!!(component::ImplicitSystem, x, y)\n\nForce re-evaluation of the residuals of an explicit system's subcomponents.\n\nStore in the x_f, y_f, and r fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_residuals!-Tuple{ImplicitSystem,Any,Any,Any,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_residuals!","text":"subcomponent_residuals!(component::ImplicitSystem, xsub, ysub, rsub, x, y)\n\nEvaluate the residuals of an implicit system's subcomponents and store the results in xsub, ysub, and rsub.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_residuals!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_residuals!","text":"subcomponent_residuals!(component::ImplicitSystem, x, y)\n\nEvaluate the residuals of an implicit system's subcomponents.\n\nStore in the x_f, y_f, and r fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_residuals_and_input_jacobians!!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_residuals_and_input_jacobians!!","text":"subcomponent_residuals_and_input_jacobians!!(component::ImplicitSystem, x, y)\n\nForce (re-)evaluation the residuals and input jacobians of an implicit system's subcomponents.\n\nStore in the x_dfdx, y_dfdx, r, and drdx fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_residuals_and_input_jacobians!-Tuple{ImplicitSystem,Any,Any,Any,Any,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_residuals_and_input_jacobians!","text":"subcomponent_residuals_and_input_jacobians!(component::ImplicitSystem, xsub,\n    ysub, rsub, dsub, x, y)\n\nEvaluate the residuals and input jacobians of an implicit system's subcomponents. Store the results in xsub, ysub, rsub, and dsub.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_residuals_and_input_jacobians!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_residuals_and_input_jacobians!","text":"subcomponent_residuals_and_input_jacobians!(component::ImplicitSystem, x, y)\n\nEvaluate the residuals and input jacobians of an implicit system's subcomponents.\n\nStore in the x_dfdx, y_dfdx, r, and drdx fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_residuals_and_jacobians!!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_residuals_and_jacobians!!","text":"subcomponent_residuals_and_jacobians!!(component::ImplicitSystem, x, y)\n\nForce (re-)evaluation of the residuals and output jacobians of an implicit system's subcomponents.\n\nStore in the x_dfdy, y_dfdy, r, and drdy fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_residuals_and_jacobians!-Tuple{ImplicitSystem,Any,Any,Any,Any,Any,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_residuals_and_jacobians!","text":"subcomponent_residuals_and_jacobians!(component::ImplicitSystem, xsub,\n    ysub, rsub, dsub, x, y)\n\nEvaluate the residuals and jacobians of an implicit system's subcomponents. Store the results in xsub, ysub, rsub, dxsub, and dysub.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_residuals_and_jacobians!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_residuals_and_jacobians!","text":"subcomponent_residuals_and_jacobians!(component::ImplicitSystem, x, y)\n\nEvaluate the residuals and jacobians of an implicit system's subcomponents.\n\nStore in the x_dfdy, y_dfdy, r, drdx, and drdy fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_residuals_and_output_jacobians!!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_residuals_and_output_jacobians!!","text":"subcomponent_residuals_and_output_jacobians!!(component::ImplicitSystem, x, y)\n\nForce (re-)evaluation of the residuals and output jacobians of an implicit system's subcomponents.\n\nStore in the x_dfdy, y_dfdy, r, and drdy fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_residuals_and_output_jacobians!-Tuple{ImplicitSystem,Any,Any,Any,Any,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_residuals_and_output_jacobians!","text":"subcomponent_residuals_and_output_jacobians!(component::ImplicitSystem, xsub,\n    ysub, rsub, dsub, x, y)\n\nEvaluate the residuals and output jacobians of an implicit system's subcomponents. Store the results in xsub, ysub, rsub, and dsub.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_residuals_and_output_jacobians!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_residuals_and_output_jacobians!","text":"subcomponent_residuals_and_output_jacobians!(component::ImplicitSystem, x, y)\n\nEvaluate the residuals and output jacobians of an implicit system's subcomponents.\n\nStore in the x_dfdy, y_dfdy, r, and drdy fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.system_component_mapping-Tuple{Any,Any}","page":"Library","title":"CoupledSystems.system_component_mapping","text":"system_component_mapping(components, argin)\n\nConstructs the component input-output mapping for a system based on input and output argument names.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.system_output_mapping-Tuple{Any,Any,Any}","page":"Library","title":"CoupledSystems.system_output_mapping","text":"system_output_mapping(components, argin, argout)\n\nConstructs the output mapping for a system based on input and output argument names of the system and components.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.update_system_input_jacobian!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.update_system_input_jacobian!","text":"update_system_input_jacobian!(system::ImplicitSystem, drdx, dsub)\n\nUpdate the input jacobian drdx to correspond to the subcomponent input jacobians in dsub.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.update_system_input_jacobian!-Tuple{ImplicitSystem}","page":"Library","title":"CoupledSystems.update_system_input_jacobian!","text":"update_system_input_jacobian!(system::ImplicitSystem)\n\nUpdate the input jacobian matrix in component to correspond to the subcomponent residuals.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.update_system_output_jacobian!-Tuple{ImplicitSystem,Any,Any,Any}","page":"Library","title":"CoupledSystems.update_system_output_jacobian!","text":"update_system_output_jacobian!(system::ImplicitSystem, drdy, dsub)\n\nUpdate the output jacobian drdy to correspond to the subcomponent output jacobians in dsub.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.update_system_output_jacobian!-Tuple{ImplicitSystem}","page":"Library","title":"CoupledSystems.update_system_output_jacobian!","text":"update_system_output_jacobian!(system::ImplicitSystem)\n\nUpdate the output jacobian in system to correspond to the subcomponent input and output jacobians.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.update_system_outputs!-NTuple{4,Any}","page":"Library","title":"CoupledSystems.update_system_outputs!","text":"update_system_outputs!(component, y, x, ysub)\n\nUpdate the outputs y given the inputs x and the component outputs ysub.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.update_system_outputs!-Tuple{Any,Any}","page":"Library","title":"CoupledSystems.update_system_outputs!","text":"update_system_outputs!(component, x)\n\nUpdate the outputs in component given the inputs x.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.update_system_residuals!-Tuple{Any,Any,Any}","page":"Library","title":"CoupledSystems.update_system_residuals!","text":"update_system_residuals!(component, r, rsub)\n\nUpdate the residuals r to make them correspond to the subcomponent residuals in rsub.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.update_system_residuals!-Tuple{Any}","page":"Library","title":"CoupledSystems.update_system_residuals!","text":"update_system_residuals!(component)\n\nUpdate the residuals in component to correspond to the subcomponent residuals.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.vectorize","page":"Library","title":"CoupledSystems.vectorize","text":"vectorize(x)\n\nConverts x to a vector.\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"@index ```","category":"page"},{"location":"#CoupledSystems","page":"Home","title":"CoupledSystems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Easily model and obtain analytic derivatives of arbitrarily complex coupled systems","category":"page"},{"location":"","page":"Home","title":"Home","text":"Author: Taylor McDonnell","category":"page"},{"location":"","page":"Home","title":"Home","text":"CoupledSystems is a modeling framework for easily modeling and obtaining exact derivatives of arbitrarily complex coupled systems.  It is similar in nature to OpenMDAO, but relies on a different theoretical foundation for propagating derivatives (and is written in Julia!).  It is also designed to automatically interface with a variety of packages in the Julia ecosystem to make obtaining derivatives and solving nonlinear systems of equations relatively painless.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Can be used to:\nPerform mixed-mode automatic differentiation\nConstruct objective and constraint functions (with exact derivatives) for gradient-based optimization.\nEasily construct monolithic coupled systems of equations from an arbitrary number of systems of equations.\nPerform efficient sensitivity analyses and obtain exact derivatives (to machine precision)\nAutomatically calculates partial derivatives using:\nFinite Differencing (Implemented using FiniteDiff)\nForward\nCentral\nComplex Step\nAutomatic Differentiation\nForward Mode (Implemented using ForwardDiff)\nReverse Mode (Implemented using ReverseDiff)\nUser-defined analytic calculations\nAutomatically calculates total derivatives using the\nChain Rule (for explicit systems)\nForward\nReverse\nAnalytic Sensitivity Equations (for implicit systems)\nDirect\nAdjoint\nMultiple solvers available for solving implicit systems\nTrust Region (Implemented using NLsolve)\nNewton's Method with Line Search (Implemented using NLsolve)\nUser-defined solvers\nEfficient and convenient calling interface\nOutput only, derivative only, and/or combined output and derivative calculation functions\nNon-allocating interface to reduce/eliminate run-time allocations\nAllocating interface for derivative verification using ForwardDiff\nOnly calculates new values/derivatives for each component/subcomponent if inputs have been updated (unless otherwise specified)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Enter the package manager by typing ] and then run the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add CoupledSystems","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See Getting Started: The Sellar Problem","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Martins, Joaquim R. R. A., and Ning, Andrew, Engineering Design Optimization, Cambridge University Press, 2021.","category":"page"}]
}
