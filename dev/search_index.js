var documenterSearchIndex = {"docs":
[{"location":"guide/#Getting-Started:-The-Sellar-Problem","page":"Getting Started","title":"Getting Started: The Sellar Problem","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"The Sellar problem is is a two-discipline toy problem introduced by R.S. Sellar, S.M. Batill, and J.E. Renaud in \"Response Surface Based, Concurrent Subspace Optimization for Multidisciplinary System Design\".  The problem itself is non-physical, but it provides a simple example with which to demonstrate multidisciplinary coupling and analysis capabilities.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Each of the two disciplines in the Sellar problem consists of a single explicit equation.  The output of each discipline is used as an input to the other discipline.  Together, the two disciplines form a nonlinear system of equations which must be solved in order to obtain valid outputs.  The outputs of the coupled system of equations are used to construct objective and constraint functions for an optimization. The following is an XDSM diagram of the problem structure.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Our goal is to manipulate this problem in order to create a single explicit function/component which defines the objective and constraint values as well as their derivatives with respect to the design variables (the inputs).  In other words, we would like to take the diagram shown above and convert it to the following one-component system, and propagate derivatives while doing so.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"guide/#Constructing-Explicit-Components","page":"Getting Started","title":"Constructing Explicit Components","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Let's start by loading the package, and then constructing each of the components of the Sellar problem individually.  Since all of the components (when considered in isolation) are explicit, we model them as such.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"using CoupledSystems\n\n# --- Define Discipline 1 --- #\n\n# vector valued input-output function\nfunction f_d1(outputs, inputs)\n    z1 = inputs[1]\n    z2 = inputs[2]\n    x = inputs[3]\n    y2 = inputs[4]\n    outputs[1] = z1^2 + z2 + x - 0.2*y2\nend\n\n# define arrays that define size and type of inputs and outputs\ninputs_d1 = zeros(4)\noutputs_d1 = zeros(1)\n\n# construct explicit component for discipline 1\nd1 = ExplicitComponent(inputs_d1, outputs_d1; f=f_d1, deriv=ForwardFD())\n\n# --- Define Discipline 2 --- #\n\n# vector valued input-output function\nfunction f_d2(outputs, inputs)\n    z1 = inputs[1]\n    z2 = inputs[2]\n    y1 = inputs[3]\n    outputs[1] = sqrt(y1) + z1 + z2\nend\n\n# define arrays that define size and type of inputs and outputs\ninputs_d2 = zeros(3)\noutputs_d2 = zeros(1)\n\n# construct explicit component for discipline 2\nd2 = ExplicitComponent(inputs_d2, outputs_d2; f=f_d2, deriv=ForwardFD())\n\n# --- Define Objective --- #\n\nfunction f_obj(outputs, inputs)\n    z1 = inputs[1]\n    x = inputs[2]\n    y1 = inputs[3]\n    y2 = inputs[4]\n    outputs[1] = x^2 + z1 + y1 + exp(-y2) # objective\nend\n\n# define arrays that define size and type of inputs and outputs\ninputs_obj = zeros(4)\noutputs_obj = zeros(1)\n\n# construct explicit component for objective\nobj = ExplicitComponent(inputs_obj, outputs_obj; f=f_obj, deriv=ForwardFD())\n\n# --- Define Constraint 1 --- #\n\nfunction f_c1(outputs, inputs)\n    y1 = inputs[1]\n    outputs[1] = 3.16 - y1\nend\n\n# define arrays that define size and type of inputs and outputs\ninputs_c1 = zeros(1)\noutputs_c1 = zeros(1)\n\n# construct explicit component for constraint 1\nc1 = ExplicitComponent(inputs_c1, outputs_c1; f=f_c1, deriv=ForwardFD())\n\n# --- Define Constraint 2 --- #\n\nfunction f_c2(outputs, inputs)\n    y2 = inputs[1]\n    outputs[1] = y2 - 24.0\nend\n\n# define arrays that define size and type of inputs and outputs\ninputs_c2 = zeros(1)\noutputs_c2 = zeros(1)\n\n# construct explicit component for constraint 2\nc2 = ExplicitComponent(inputs_c2, outputs_c2; f=f_c2, deriv=ForwardFD())\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Note that rather than providing the jacobians of each function directly, we use forward finite differencing to estimate the jacobian of each component. This is the default behavior of CoupledSystems.  Other provided jacobian calculation methods include CentralFD(), ComplexFD(), ForwardAD(), and ReverseAD().  It's also possible to provide your own jacobian function through the df keyword argument.","category":"page"},{"location":"guide/#Converting-Explicit-Components-into-Implicit-Components","page":"Getting Started","title":"Converting Explicit Components into Implicit Components","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"We would like to be able to converge all interdependent components simultaneously.  This can be done with the help of a nonlinear solver.  Let's go ahead and add one to the XDSM diagram.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Notice that the two disciplinary components have been converted to implicit components so that they can provide residual vectors to the nonlinear solver.  The nonlinear solver then drives these residuals to zero and provides the final states/outputs y_1 and y_2 to the rest of the system.  Let's go ahead and convert our explicit components to implicit components so that they can be used to provide residual vectors (and associated derivatives) to the nonlinear solver.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# convert discipline 1 into an implicit component\nd1i = ImplicitComponent(d1)\n\n# convert discipline 2 into an implicit component\nd2i = ImplicitComponent(d2)\n\nnothing #hide","category":"page"},{"location":"guide/#Combining-Implicit-Components-into-an-Implicit-System","page":"Getting Started","title":"Combining Implicit Components into an Implicit System","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"At this point we combine the two implicit components to create a single set of residual equations.  The state variables (which are also the system outputs) are also combined.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"\n# define input mapping for discipline 1\nmapping_1 = [\n    (0, 1), # first input (z1) is index 1 of the system inputs\n    (0, 2), # second input (z2) is index 2 of the system inputs\n    (0, 3), # third input (x) is index 3 of the system inputs\n    (2, 1), # fourth input (y2) is the first output from discipline 2\n]\n\n# define input mapping for discipline 2\nmapping_2 = [\n    (0, 1), # first input (z1) is index 1 of the system inputs\n    (0, 2), # second input (z2) is index 2 of the system inputs\n    (1, 1), # third input is the first output from the first component\n]\n\n# array that defines size and types of the inputs\ninputs_isys = zeros(3)\n\n# components in the implicit system\ncomponents_isys = [d1i, d2i]\n\n# input mapping for components in the implicit system\ncomponent_mapping_isys = [mapping_1, mapping_2]\n\n# implicit system construction\nisys = ImplicitSystem(inputs_isys, components_isys, component_mapping_isys)\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Let's now update the XDSM diagram to account for the newly combined system.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"guide/#Coupling-an-Implicit-Component-with-a-Solver-to-Construct-an-Explicit-Component","page":"Getting Started","title":"Coupling an Implicit Component with a Solver to Construct an Explicit Component","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Now that we have a single implicit system of equations, we can couple it with the nonlinear solver, which will effectively convert it into an explicit component.  The outputs of the resulting explicit component will be equal to the outputs of each of the implicit system's subcomponents, concatenated.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"mda = ExplicitComponent(isys, solver=Newton())\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Here is the XDSM diagram of the Sellar problem after combining the implicit system of equations with the nonlinear solver to create an explicit component.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"guide/#Combining-Explicit-Components-into-an-Explicit-System","page":"Getting Started","title":"Combining Explicit Components into an Explicit System","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Since there are no longer any model interdependencies, each component may be called sequentially to generate the final output.  We can express this sequence of explicit components as a single explicit system with its own set of inputs and outputs","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"\n# define input mapping for the multidisciplinary analysis\nmapping_mda = [\n    (0, 1), # first input (z1) is index 1 of the system inputs\n    (0, 2), # second input (z2) is index 2 of the system inputs\n    (0, 3), # third input (x) is index 3 of the system inputs\n]\n\n# define input mapping for the objective\nmapping_obj = [\n    (0, 1), # first input (z1) is index 1 of the system inputs\n    (0, 3), # second input (x) is index 3 of the system inputs\n    (1, 1), # third input (y1) is the first output from the multidisciplinary analysis\n    (1, 2), # fourth input (y2) is the second output from the multidisciplinary analysis\n]\n\n# define input mapping for the first constraint\nmapping_g1 = [\n    (1, 1), # first input (y1) is the first output from the multidisciplinary analysis\n]\n\n# define input mapping for the second constraint\nmapping_g2 = [\n    (1, 2), # first input (y2) is the second output from the multidisciplinary analysis\n]\n\n# array defining size and type of inputs to the explicit system\ninputs_sellar = zeros(3)\n\n# components in the explicit system\ncomponents_sellar = [mda, obj, c1, c2]\n\n# input mapping for each of the components\ncomponent_mapping_sellar = [mapping_mda, mapping_obj, mapping_g1, mapping_g2]\n\n# array defining size and type of outputs from the explicit system\noutputs_sellar = zeros(3)\n\n# output mapping for the combined system\noutput_mapping_sellar = [\n    (2, 1), # first output is the first output from the second component\n    (3, 1), # second output is the first output from the third component\n    (4, 1), # third output is the first output from the fourth component\n]\n\nsellar = ExplicitSystem(inputs_sellar, outputs_sellar, components_sellar,\n    component_mapping_sellar, output_mapping_sellar; mode=Reverse())\n\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"At this point we have achieved our goal of representing the Sellar problem as an explicit one-component system.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"guide/#Querying-Explicit-Components-and/or-Systems","page":"Getting Started","title":"Querying Explicit Components and/or Systems","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Now that our entire system has been reduced down into a single explicit component, we can easily obtain the outputs and their derivatives with respect to the design variables for any set of design variables.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"# inputs to the Sellar problem\nx = rand(3)\n\n# outputs from the Sellar problem\ny = outputs!(sellar, x)\n\n# jacobian of the outputs with respect to the inputs\ndydx = jacobian!(sellar, x)\n\n# combined evaluation of outputs and jacobian\ny, dydx = outputs_and_jacobian!(sellar, x)\n\nnothing #hide","category":"page"},{"location":"guide/#Verifying-Derivatives","page":"Getting Started","title":"Verifying Derivatives","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Derivatives can be verified easily using finite differencing.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"using FiniteDiff\n\n# Verify using forward finite differencing\nf = (x) -> outputs(sellar, x)\ndydx_fd = FiniteDiff.finite_difference_jacobian(f, x)\nprintln(\"Maximum Error: \", maximum(abs.(dydx - dydx_fd)))\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"For an even better derivative check, the jacobians can be verified against exact derivatives computed using forward mode automatic differentiation.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"using ForwardDiff\n\n# Verify using forward mode automatic differentiation\ndydx_ad = ForwardDiff.jacobian(f, x)\nerror = dydx - dydx_ad\nprintln(\"Maximum Error: \", maximum(abs.(dydx - dydx_ad)))\nnothing #hide","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Since this package uses analytic expressions to propagate derivatives, the derivatives computed by this package combined with finite differencing are actually a couple orders of magnitude more accurate than those computed using finite differencing alone.","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"error = dydx - dydx_ad\nerror_fd = dydx_fd - dydx_ad\nprintln(\"Maximum Error using Finite Differencing: \",\n    maximum(abs.(dydx_fd - dydx_ad)))\nprintln(\"Maximum Error using Finite Differencing and CoupledSystems: \",\n    maximum(abs.(dydx - dydx_ad)))\nnothing #hide","category":"page"},{"location":"guide/#Final-Notes","page":"Getting Started","title":"Final Notes","text":"","category":"section"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"While the intended use of CoupledSystems is typically to reduce an arbitrarily complex system down to a single explicit component, there are multiple ways in which this may be accomplished.  For example, an alternative approach to modeling the Sellar problem would be to construct a single implicit system from all components and then couple that system with a nonlinear solver (which is effectively the approach used in OpenMDAO).  ","category":"page"},{"location":"guide/","page":"Getting Started","title":"Getting Started","text":"Additionally, there are multiple ways in which any given problem may be divided up into components.  For example, we could have defined the objective and constraint functions as a single vector-valued function rather than three.  Ultimately, while these choices may seem arbitrary, different combinations of choices may be more computationally efficient than others, especially for derivative computations.","category":"page"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"CoupledSystems is developed around the idea that most functions and/or system components may be modeled as either an explicit vector valued function y = f(x) or an implicit vector-valued residual function 0 = r(x y), where x is a vector which contains the inputs to a system component and y is a vector which contains the outputs from a system component.  For implicit components, valid outputs correspond to those which satisfy the vector valued residual function 0 = r(xy) for a given set of inputs x.","category":"page"},{"location":"theory/#The-Relationship-between-Explicit-and-Implicit-Components","page":"Theory","title":"The Relationship between Explicit and Implicit Components","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Explicit components may easily be converted to implicit components by subtracting the provided outputs bary from the actual outputs y = f(x), resulting in the following residual equation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"0 = r(x bary) = f(x) - bary","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Implicit components, on the other hand, may be effectively \"seen\" as explicit components once they are coupled with a solver which converges their residual equations to zero.  For example, while a computational fluid dynamics program internally solves an implicit system of equations to obtain fluid properties throughout a domain, programs which call the same CFD package effectively see the CFD package as an explicit component from which they expect to receive a converged set of outputs y given a set of inputs x.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"There is an important caveat in the effective conversion from implicit to explicit components.  While explicit components inherently contain a one-to-one mapping between inputs and outputs, the same is not true for implicit components.  Multiple sets of outputs may be able to satisfy the residual equations of an implicit component for a given set of inputs.  If a one-to-one mapping does not exist for a given implicit component, then the outputs from that component are dependent on the choice of solver and initial output guess in addition to the inputs (if a solution exists at all!).","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: )","category":"page"},{"location":"theory/#Derivatives-of-Explicit-and-Implicit-Components","page":"Theory","title":"Derivatives of Explicit and Implicit Components","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"It is often useful to obtain the sensitivities of the outputs of a given system to its inputs.  This helps to both understand the system and inform gradient-based optimization.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The sensitivities of the outputs to the inputs for an explicit component is simply the partial derivative of the output function with respect to the inputs.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"fracdydx = fracpartial fpartial x","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The partial derivatives fracpartial fpartial x may be computed analytically, with automatic differentiation, and/or with finite differencing.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"To obtain the sensitivities of the outputs with respect to the inputs for an implicit component we first take the total derivative of the residual function with respect to the inputs.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"fracdrdx = fracpartial rpartial x + fracpartial rpartial yfracdydx","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The total derivative fracdrdx in this expression is zero since any change in the inputs for a valid set of outputs will still result in a zero-valued residual function.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"0 = fracpartial rpartial x + fracpartial rpartial yfracdydx","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"We now manipulate this expression to obtain the derivative of the outputs with respect to the inputs.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"fracdydx = -left(fracpartial rpartial yright)^-1fracpartial rpartial x","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The partial derivatives fracpartial rpartial x and fracpartial rpartial y may be computed analytically, with automatic differentiation, and/or with finite differencing.  Note that the converged set of outputs y must be used when calculating the partials to obtain a valid set of derivatives.","category":"page"},{"location":"theory/#Explicit-Systems","page":"Theory","title":"Explicit Systems","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"We define an explicit system as a system containing explicit components where each component's inputs correspond to either one of the previously evaluated component's outputs or the system inputs.  An illustration of an explicit system is shown in the following diagram.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: )","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"An explicit system maps a set of inputs to a set of outputs through an explicit input-output relationship.  It may therefore be seen as a single explicit component composed of multiple explicit components.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: )","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Since there are no implicit dependencies in an explicit system, the chain rule may be used in forward or reverse mode to calculate the derivatives of the outputs with respect to the inputs.  ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The computational cost of applying the chain rule scales linearly with either the inputs or outputs depending on whether the chain rule is applied in forward or reverse mode respectively.  It is therefore advised to apply the chain rule in forward mode if the number of outputs exceeds the number of inputs and reverse mode otherwise.","category":"page"},{"location":"theory/#Implicit-Systems","page":"Theory","title":"Implicit Systems","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"We define an implicit system as a system containing implicit components where the system's residuals and outputs correspond to each of its subcomponents residuals and outputs concatenated.  The inputs to each subcomponent may correspond to the system inputs and/or the outputs of any other subcomponent.  An illustration of an implicit system is shown in the following diagram.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: )","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Since explicit components may be easily converted to implicit components, implicit systems may be used to model any combination of explicit and implicit components.  Implicit systems may be viewed as a single implicit component with a set of residual equations and outputs corresponding to those of its subcomponents.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: )","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The partial derivatives of an implicit system with respect to its inputs and outputs may be constructed using the partial derivatives of its subcomponents with respect to their inputs and outputs.  In many cases, the resulting matrix will be sparse.","category":"page"},{"location":"theory/#Analytical-Sensitivity-Equations","page":"Theory","title":"Analytical Sensitivity Equations","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"As we have defined them, the outputs of implicit components (including implicit systems) are identical to the state variables of the system.  In many cases, however, implicit components are coupled with output equations which calculate a relatively small number of important outputs from the inputs and state variables of an implicit component.  In this case, we can apply the analytic sensitivity equations to drastically reduce the computational cost of computing the derivatives of the implicit component.  ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The cost of applying the analytic sensitivity equations scales linearly with the number of inputs or outputs in direct or adjoint mode respectively. It is therefore advised to use the direct mode of the analytic sensitivity equations when the number of outputs exceeds the number of inputs and adjoint mode otherwise.","category":"page"},{"location":"theory/#Reducing-Systems-of-Components-to-a-Single-Explicit-Component","page":"Theory","title":"Reducing Systems of Components to a Single Explicit Component","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Any system composed of explicit and implicit components may be reduced to a single explicit component.  For example, all components may be converted into implicit components, combined into a single implicit system, and then converted to an explicit component.  Alternatively, interdependent components may be combined together into implicit systems which may then be converted into explicit components and then combined with other explicit components into an explicit system.  While the result of the different approaches is the same, the computationally efficiency may vary.  For example, the latter approach for combining components together is likely more computationally efficient than the former approach.   In any case, once the system has been reduced into a single explicit component, that component may be used to easily obtain outputs and derivatives of the outputs with respect to the inputs given a set of inputs.","category":"page"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages = [\"library.md\"]\nDepth = 3","category":"page"},{"location":"library/#Public-API","page":"Library","title":"Public API","text":"","category":"section"},{"location":"library/#Differentiation-Methods","page":"Library","title":"Differentiation Methods","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"AbstractDiffMethod\nAbstractAD\nForwardAD\nReverseAD\nAbstractFD\nForwardFD\nCentralFD\nComplexFD\nForward\nReverse\nDirect\nAdjoint","category":"page"},{"location":"library/#CoupledSystems.AbstractDiffMethod","page":"Library","title":"CoupledSystems.AbstractDiffMethod","text":"AbstractDiffMethod\n\nAbstract type representing different differentiation methods\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.AbstractAD","page":"Library","title":"CoupledSystems.AbstractAD","text":"AbstractAD\n\nAbstract type representing different automatic differentation methods\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.ForwardAD","page":"Library","title":"CoupledSystems.ForwardAD","text":"ForwardAD{T} <: AbstractAD\n\nForward automatic differentiation using the ForwardDiff package.\n\nFields:\n\nchunk::T: Chunk size\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.ReverseAD","page":"Library","title":"CoupledSystems.ReverseAD","text":"ReverseAD <: AbstractAD\n\nReverse automatic differentiation using the ReverseDiff package.\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.AbstractFD","page":"Library","title":"CoupledSystems.AbstractFD","text":"AbstractFD\n\nAbstract type representing different finite difference methods\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.ForwardFD","page":"Library","title":"CoupledSystems.ForwardFD","text":"ForwardFD <: AbstractFD\n\nForward finite differencing as implemented by the FiniteDiff package\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.CentralFD","page":"Library","title":"CoupledSystems.CentralFD","text":"CentralFD <: AbstractFD\n\nCentral finite differencing as implemented by the FiniteDiff package\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.ComplexFD","page":"Library","title":"CoupledSystems.ComplexFD","text":"ComplexFD <: AbstractFD\n\nComplex step finite differencing as implemented by the FiniteDiff package\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.Forward","page":"Library","title":"CoupledSystems.Forward","text":"Forward <: AbstractChainRuleMode\n\nType indicating that the chain rule should be applied in forward mode\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.Reverse","page":"Library","title":"CoupledSystems.Reverse","text":"Reverse <: AbstractChainRuleMode\n\nType indicating that the chain rule should be applied in reverse mode\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.Direct","page":"Library","title":"CoupledSystems.Direct","text":"Direct <: AbstractSensitivityMode\n\nType indicating that the analytic sensitivity equations should be applied using the direct method.\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.Adjoint","page":"Library","title":"CoupledSystems.Adjoint","text":"Adjoint <: AbstractSensitivityMode\n\nType indicating that the analytic sensitivity equations should be applied using the adjoint method.\n\n\n\n\n\n","category":"type"},{"location":"library/#Sparsity","page":"Library","title":"Sparsity","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"AbstractSparsityPattern\nDensePattern\nSparsePattern","category":"page"},{"location":"library/#CoupledSystems.AbstractSparsityPattern","page":"Library","title":"CoupledSystems.AbstractSparsityPattern","text":"AbstractSparsityPattern\n\nAbstract type representing the sparsity pattern of a jacobian matrix\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.DensePattern","page":"Library","title":"CoupledSystems.DensePattern","text":"DensePattern <: AbstractSparsityPattern\n\nType which indicates that a jacobian is dense\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.SparsePattern","page":"Library","title":"CoupledSystems.SparsePattern","text":"SparsePattern{TI} <: AbstractSparsityPattern\n\nType which indicates that a jacobian is sparse and indicates the non-zero rows and columns\n\nFields:\n\nrows::Vector{TI}: Row of each non-zero matrix element\ncols::Vector{TI}: Column of each non-zero matrix element\n\n\n\n\n\n","category":"type"},{"location":"library/#Constructors","page":"Library","title":"Constructors","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"AbstractComponent\nAbstractExplicitComponent\nExplicitComponent\nExplicitSystem\nAbstractImplicitComponent\nImplicitComponent\nImplicitSystem","category":"page"},{"location":"library/#CoupledSystems.AbstractComponent","page":"Library","title":"CoupledSystems.AbstractComponent","text":"AbstractComponent\n\nSupertype for all components\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.AbstractExplicitComponent","page":"Library","title":"CoupledSystems.AbstractExplicitComponent","text":"AbstractExplicitComponent <: AbstractComponent\n\nSupertype for components defined by the vector valued output function y = f(x)\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.ExplicitComponent","page":"Library","title":"CoupledSystems.ExplicitComponent","text":"ExplicitComponent{TX, TY, TJ} <: AbstractExplicitComponent\n\nSystem component defined by the explicit vector-valued output function: y = f(x)\n\nFields\n\nf: In-place output function f(y, x)\ndf: In-place jacobian function df(dydx, x)\nfdf: In-place combined output and jacobian function fdf(y, dydx, x)\nx_f::TX: Inputs used to evaluate the outputs\nx_df::TX: Inputs used to evaluate the jacobian\ny::TY: Outputs\ndydx::TJ: Jacobian\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.ExplicitSystem","page":"Library","title":"CoupledSystems.ExplicitSystem","text":"ExplicitSystem{TC, TX, TY, TJ, TD} <: AbstractExplicitComponent\n\nExplicit system constructed from a chain of explicit system components called sequentially.\n\nFields\n\ncomponents::TC: Collection of components, in calling order\ninput_mapping::Vector{NTuple{2,Vector{Int}}}:\ncomponent_output_mapping::Vector{Vector{NTuple{2,Vector{Int}}}}:\ncomponent_input_mapping::Vector{Vector{NTuple{2,Int}}}:\noutput_mapping::Vector{NTuple{2,Int}}:\nx_f::TX: Inputs used to evaluate the system outputs\nx_df::TX: Inputs used to evaluate the system jacobian\ny::TY: Storage for the system outputs\ndydx::TJ: Storage for the system jacobian\nmode::TD: Default direction in which to apply the chain rule (Forward() or Reverse())\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.AbstractImplicitComponent","page":"Library","title":"CoupledSystems.AbstractImplicitComponent","text":"AbstractImplicitComponent <: AbstractComponent\n\nSupertype for components defined by the vector valued residual function 0 = f(x, y)\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.ImplicitComponent","page":"Library","title":"CoupledSystems.ImplicitComponent","text":"ImplicitComponent{TX, TY, TR, TDRX, TDRY} <: AbstractImplicitComponent\n\nSystem component defined by the vector-valued residual function: 0 = f(x, y)\n\nFields\n\nf: In-place residual function f(r, x, y).\ndfdx: In-place residual jacobian function with respect to the inputs dfdx(drdx, x, y)\ndfdy: In-place residual jacobian function with respect to the outputs dfdy(drdy, x, y)\nfdfdx: In-place combined residual and jacobian with respect to the inputs function fdfdx(r, drdx, x, y).\nfdfdy: In-place combined residual and jacobian with respect to the outputs function fdfdy(r, drdy, x, y).\nfdf: In-place combined residual and jacobians function fdf(r, drdx, drdy, x, y).\nx_f::TX: x used to evaluate f\ny_f::TY: y used to evaluate f\nx_dfdx::TX: x used to evaluate dfdx\ny_dfdx::TY: y used to evaluate dfdx\nx_dfdy::TX: x used to evaluate dfdy\ny_dfdy::TY: y used to evaluate dfdy\nr::TR: cache for residual`\ndrdx::TDRX: cache for residual jacobian with respect to x\ndrdy::TDRY: cache for residual jacobian with respect to y\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.ImplicitSystem","page":"Library","title":"CoupledSystems.ImplicitSystem","text":"ImplicitSystem{TC, TX, TY, TR, TDRX, TDRY} <: AbstractImplicitComponent\n\nImplicit system constructed from interdependent explicit and/or implicit system components.\n\nFields\n\ncomponents::TC: Collection of components, in preferred calling order\ncomponent_input_mapping::Vector{Vector{NTuple{2,Int}}}:\nx_f::TX: x used to evaluate f\ny_f::TY: y used to evaluate f\nx_dfdx::TX: x used to evaluate dfdx\ny_dfdx::TY: y used to evaluate dfdx\nx_dfdy::TX: x used to evaluate dfdy\ny_dfdy::TY: y used to evaluate dfdy\nr::TR: cache for residual`\ndrdx::TDRX: cache for residual jacobian with respect to x\ndrdy::TDRY: cache for residual jacobian with respect to y\nidx::Vector{Int}: Index used for accessing outputs/residuals for each component\n\n\n\n\n\n","category":"type"},{"location":"library/#Solvers","page":"Library","title":"Solvers","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"AbstractSolver\nNewton","category":"page"},{"location":"library/#CoupledSystems.AbstractSolver","page":"Library","title":"CoupledSystems.AbstractSolver","text":"AbstractSolver\n\nSupertype for solvers that may be used to solve implicit systems of equations.\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.Newton","page":"Library","title":"CoupledSystems.Newton","text":"Newton{T1, T2, T3, T4, T5}\n\nFields\n\nxtol::T1: Step size tolerance for ending iterations\nftol::T2: Function tolerance for ending iterations\niterations::T3: Maximum number of iterations\nlinesearch::T4: Linesearch algorithm\nlinsolve::T5: Linear solver algorithm\n\n\n\n\n\n","category":"type"},{"location":"library/#Calling-Interface","page":"Library","title":"Calling Interface","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"outputs\noutputs!\noutputs!!\noutputs!!!\njacobian\njacobian!\njacobian!!\njacobian!!!\noutputs_and_jacobian\noutputs_and_jacobian!\noutputs_and_jacobian!!\noutputs_and_jacobian!!!\nresiduals\nresiduals!\nresiduals!!\nresiduals!!!\nresidual_input_jacobian\nresidual_input_jacobian!\nresidual_input_jacobian!!\nresidual_input_jacobian!!!\nresidual_output_jacobian\nresidual_output_jacobian!\nresidual_output_jacobian!!\nresidual_output_jacobian!!!\nresiduals_and_input_jacobian\nresiduals_and_input_jacobian!\nresiduals_and_input_jacobian!!\nresiduals_and_input_jacobian!!!\nresiduals_and_output_jacobian\nresiduals_and_output_jacobian!\nresiduals_and_output_jacobian!!\nresiduals_and_output_jacobian!!!\nresiduals_and_jacobians\nresiduals_and_jacobians!\nresiduals_and_jacobians!!\nresiduals_and_jacobians!!!","category":"page"},{"location":"library/#CoupledSystems.outputs","page":"Library","title":"CoupledSystems.outputs","text":"outputs(component::AbstractComponent)\n\nReturn the outputs stored in component.\n\n\n\n\n\noutputs(component::AbstractExplicitComponent, x)\n\nEvaluate the outputs of an explicit system component.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.outputs!","page":"Library","title":"CoupledSystems.outputs!","text":"outputs!(component::AbstractExplicitComponent, y, x)\n\nEvaluate the outputs of an explicit system component and store the result in y.\n\nThis does not update any of the values stored in component\n\n\n\n\n\noutputs!(component::ExplicitSystem, y, xsub, ysub, x)\n\nEvaluate the outputs of an explicit system and store the result in y. Store the intermediate results in xsub and ysub.\n\nThis does not update any of the values stored in component\n\n\n\n\n\noutputs!(component::AbstractExplicitComponent, x)\n\nEvaluate the outputs of an explicit system component.\n\nReturn the result and store in component.y.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.outputs!!","page":"Library","title":"CoupledSystems.outputs!!","text":"outputs!!(component::AbstractExplicitComponent, x)\n\nForce (re-)evaluation of the outputs of an explicit system component.\n\nReturn the result and store in component.y.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.outputs!!!","page":"Library","title":"CoupledSystems.outputs!!!","text":"outputs!!!(component::AbstractExplicitComponent, x)\n\nForce (re-)evaluation of the outputs of an explicit system component. Also force (re-)evaluation of the outputs of the system's subcomponents.\n\nReturn the result and store in component.y.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.jacobian","page":"Library","title":"CoupledSystems.jacobian","text":"jacobian(component::AbstractExplicitComponent)\n\nReturn the jacobian of the outputs with respect to the inputs stored in component\n\n\n\n\n\njacobian(component::AbstractExplicitComponent, x)\n\nEvaluate the jacobian of the outputs with respect to the inputs.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.jacobian!","page":"Library","title":"CoupledSystems.jacobian!","text":"jacobian!(component::AbstractExplicitComponent, dydx, x)\n\nEvaluate the jacobian of the outputs with respect to the inputs and store the result in dydx\n\nThis does not update any of the values stored in component\n\n\n\n\n\njacobian!(component::ExplicitSystem, dydx, xsub, ysub, dsub, x, mode=component.mode)\n\nEvaluate the jacobian of the outputs with respect to the inputs and store the result in dydx.  Store the intermediate subcomponent x, y and dydx values in xsub, ysub, and dsub respectively.\n\nThis does not update any of the values stored in component\n\n\n\n\n\njacobian!(component::AbstractExplicitComponent, x)\n\nEvaluate the jacobian of the outputs with respect to the inputs.\n\nReturn the result and store in component.dydx.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.jacobian!!","page":"Library","title":"CoupledSystems.jacobian!!","text":"jacobian!!(component::AbstractExplicitComponent, x)\n\nForce (re-)evaluation of the jacobian of the outputs with respect to the inputs.\n\nReturn the result and store in component.dydx.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.jacobian!!!","page":"Library","title":"CoupledSystems.jacobian!!!","text":"jacobian!!!(component::AbstractExplicitComponent, x)\n\nForce (re-)evaluation of the jacobian of the outputs with respect to the inputs. Also force (re-)evaluation of the jacobians of the system's subcomponents.\n\nReturn the result and store in component.dydx.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.outputs_and_jacobian","page":"Library","title":"CoupledSystems.outputs_and_jacobian","text":"outputs_and_jacobian(component::AbstractExplicitComponent)\n\nReturn the outputs and their derivatives with respect to the inputs stored in component.\n\n\n\n\n\noutputs_and_jacobian(component::AbstractExplicitComponent, x)\n\nEvaluate the outputs and their derivatives with respect to the inputs.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.outputs_and_jacobian!","page":"Library","title":"CoupledSystems.outputs_and_jacobian!","text":"outputs_and_jacobian!(component::AbstractExplicitComponent, y, dydx, x)\n\nEvaluate the outputs and their derivatives with respect to the inputs and store the results in y and dydx\n\nThis does not update any of the values stored in component\n\n\n\n\n\noutputs_and_jacobian!(component::ExplicitSystem, y, dydx, xsub, ysub, dsub,\n    x, mode=component.mode)\n\nEvaluate the outputs and their derivatives with respect to the inputs and store the results in y and dydx.  Store the intermediate subcomponent x, y and dydx values in xsub, ysub, and dsub respectively.\n\nThis does not update any of the values stored in component\n\n\n\n\n\noutputs_and_jacobian!(component::AbstractExplicitComponent, x)\n\nEvaluate the outputs and their derivatives with respect to the inputs.\n\nReturn the result and store in component.y and component.dydx\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.outputs_and_jacobian!!","page":"Library","title":"CoupledSystems.outputs_and_jacobian!!","text":"outputs_and_jacobian!!(component::AbstractExplicitComponent, x)\n\nForce (re-)evaluation of the outputs and their derivatives with respect to the inputs.\n\nReturn the result and store in component.y and component.dydx\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.outputs_and_jacobian!!!","page":"Library","title":"CoupledSystems.outputs_and_jacobian!!!","text":"outputs_and_jacobian!!!(component::AbstractExplicitComponent, x)\n\nForce (re-)evaluation of the outputs and their derivatives with respect to the inputs for the system.  Also force (re-)evaluation of the outputs and jacobians of the system's subcomponents.\n\nReturn the result and store in component.y and component.dydx\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals","page":"Library","title":"CoupledSystems.residuals","text":"residuals(component::AbstractImplicitComponent)\n\nReturn the residuals stored in component\n\n\n\n\n\nresiduals(component::AbstractImplicitComponent, x, y)\n\nEvaluate the residuals of an implicit system component.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals!","page":"Library","title":"CoupledSystems.residuals!","text":"residuals!(component::AbstractImplicitComponent, r, x, y)\n\nEvaluate the residuals of an implicit system component and store the result in r.\n\nThis does not update any of the values stored in component\n\n\n\n\n\nresiduals!(component::ImplicitSystem, r, xsub, ysub, rsub, x, y)\n\nEvaluate the residuals of an implicit system and store the result in y. Store the intermediate results in xsub, ysub, and rsub.\n\nThis does not update any of the values stored in component\n\n\n\n\n\nresiduals!(component::AbstractImplicitComponent, x, y)\n\nEvaluate the residuals of an implicit system component.\n\nReturn the result and store in component.r\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals!!","page":"Library","title":"CoupledSystems.residuals!!","text":"residuals!!(component::AbstractImplicitComponent, x, y)\n\nForce (re-)evaluation of the residuals of an implicit system component.\n\nReturn the result and store in component.r\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals!!!","page":"Library","title":"CoupledSystems.residuals!!!","text":"residuals!!!(component::AbstractImplicitComponent, x, y)\n\nForce (re-)evaluation of the residuals of an implicit system component. Also force (re-)evaluation of the residuals of the system's subcomponents.\n\nReturn the result and store in component.r\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residual_input_jacobian","page":"Library","title":"CoupledSystems.residual_input_jacobian","text":"residual_input_jacobian(component::AbstractImplicitComponent)\n\nReturn the jacobian of the residuals with respect to the inputs stored in component.\n\n\n\n\n\nresidual_input_jacobian(component::AbstractImplicitComponent, x, y)\n\nEvaluate the jacobian of the residuals with respect to the inputs,\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residual_input_jacobian!","page":"Library","title":"CoupledSystems.residual_input_jacobian!","text":"residual_input_jacobian!(component::ImplicitComponent, drdx, x, y)\n\nEvaluate the jacobian of the residuals with respect to the inputs and store the result in drdx.\n\nThis does not update any of the values stored in component\n\n\n\n\n\nresidual_input_jacobian!(component::ImplicitSystem, drdx, xsub, ysub, rsub,\n    dsub, x, y)\n\nEvaluate the jacobian of the residual with respect to the inputs and store the result in drdx.  Store the intermediate subcomponent x, y and drdx values in xsub, ysub, and dsub respectively.\n\nThis does not update any of the values stored in component\n\n\n\n\n\nresidual_input_jacobian!(component::AbstractImplicitComponent, x, y)\n\nEvaluate the jacobian of the residuals with respect to the inputs.\n\nReturn the result and store in component.drdx\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residual_input_jacobian!!","page":"Library","title":"CoupledSystems.residual_input_jacobian!!","text":"residual_input_jacobian!!(component::ImplicitComponent, x, y)\n\nForce (re-)evaluation of the jacobian of the residuals with respect to the inputs.\n\nReturn the result and store in component.drdx\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residual_input_jacobian!!!","page":"Library","title":"CoupledSystems.residual_input_jacobian!!!","text":"residual_input_jacobian!!!(component::AbstractImplicitComponent, x, y)\n\nForce (re-)evaluation of the jacobian of the residuals with respect to the inputs. Also force (re-)evaluation of the jacobians of the system's subcomponents.\n\nReturn the result and store in component.drdx\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residual_output_jacobian","page":"Library","title":"CoupledSystems.residual_output_jacobian","text":"residual_output_jacobian(component::AbstractImplicitComponent)\n\nReturn the jacobian of the residuals with respect to the outputs stored in component.\n\n\n\n\n\nresidual_output_jacobian(component::AbstractImplicitComponent, x, y)\n\nEvaluate the jacobian of the residuals with respect to the outputs,\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residual_output_jacobian!","page":"Library","title":"CoupledSystems.residual_output_jacobian!","text":"residual_output_jacobian!(component::AbstractImplicitComponent, drdy, x, y)\n\nEvaluate the jacobian of the residuals with respect to the outputs and store the result in drdy\n\nThis does not update any of the values stored in component\n\n\n\n\n\nresidual_output_jacobian!(component::ImplicitSystem, drdy, xsub, ysub, dxsub,\n    dysub, x, y)\n\nEvaluate the jacobian of the residuals with respect to the outputs and store the result in drdx.  Store the intermediate subcomponent x, y and drdy values in xsub, ysub, and dsub respectively.\n\nThis does not update any of the values stored in component\n\n\n\n\n\nresidual_output_jacobian!(component::AbstractImplicitComponent, x, y)\n\nEvaluate the jacobian of the residuals with respect to the outputs.\n\nReturn the result and store in component.drdy\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residual_output_jacobian!!","page":"Library","title":"CoupledSystems.residual_output_jacobian!!","text":"residual_output_jacobian!!(component::AbstractImplicitComponent, x, y)\n\nForce (re-)evaluation of the jacobian of the residuals with respect to the outputs.\n\nReturn the result and store in component.drdy\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residual_output_jacobian!!!","page":"Library","title":"CoupledSystems.residual_output_jacobian!!!","text":"residual_output_jacobian!!!(component::AbstractImplicitComponent, x, y)\n\nForce (re-)evaluation of the jacobian of the residuals with respect to the outputs. Also force (re-)evaluation of the jacobians of the system's subcomponents.\n\nReturn the result and store in component.drdy\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals_and_input_jacobian","page":"Library","title":"CoupledSystems.residuals_and_input_jacobian","text":"residuals_and_input_jacobian(component::AbstractImplicitComponent)\n\nReturn the residual and jacobian of the residuals with respect to the inputs stored in component.\n\n\n\n\n\nresiduals_and_input_jacobian(component::AbstractImplicitComponent, x, y)\n\nEvaluate the residual and jacobian of the residuals with respect to the inputs.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals_and_input_jacobian!","page":"Library","title":"CoupledSystems.residuals_and_input_jacobian!","text":"residuals_and_input_jacobian!(component::AbstractImplicitComponent, r, drdx, x, y)\n\nEvaluate the residual and jacobian of the residuals with respect to the inputs and store the result in r and drdx.\n\nThis does not update any of the values stored in component\n\n\n\n\n\nresiduals_and_input_jacobian!(component::ImplicitSystem, r, drdx, xsub,\n    ysub, rsub, dsub, x, y)\n\nEvaluate the residuals and their derivatives with respect to the inputs and store the results in r and drdx.  Store the intermediate subcomponent x, y, r, and drdx values in xsub, ysub, rsub, and dsub respectively.\n\nThis does not update any of the values stored in component\n\n\n\n\n\nresiduals_and_input_jacobian!(component::AbstractImplicitComponent, x, y)\n\nEvaluate the residual and jacobian of the residuals with respect to the inputs.\n\nReturn the result and store in component.r and component.drdx\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals_and_input_jacobian!!","page":"Library","title":"CoupledSystems.residuals_and_input_jacobian!!","text":"residuals_and_input_jacobian!!(component::AbstractImplicitComponent, x, y)\n\nForce (re-)evaluation of the residual and jacobian of the residuals with respect to the inputs.\n\nReturn the result and store in component.r and component.drdx\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals_and_input_jacobian!!!","page":"Library","title":"CoupledSystems.residuals_and_input_jacobian!!!","text":"residuals_and_input_jacobian!!!(component::AbstractImplicitComponent, x, y)\n\nForce (re-)evaluation of the residual and jacobian of the residuals with respect to the inputs. Also force (re-)evaluation of each subcomponents residual and jacobian with respect to its inputs.\n\nReturn the result and store in component.r and component.drdx\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals_and_output_jacobian","page":"Library","title":"CoupledSystems.residuals_and_output_jacobian","text":"residuals_and_output_jacobian(component::AbstractImplicitComponent)\n\nReturn the residuals and jacobian of the residuals with respect to the outputs stored in component.\n\n\n\n\n\nresiduals_and_output_jacobian(component::AbstractImplicitComponent, x, y)\n\nEvaluate the residuals and jacobian of the residuals with respect to the outputs.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals_and_output_jacobian!","page":"Library","title":"CoupledSystems.residuals_and_output_jacobian!","text":"residuals_and_output_jacobian!(component::AbstractImplicitComponent, r, drdy, x, y)\n\nEvaluate the residuals and jacobian of the residuals with respect to the outputs and store the results in r and drdy\n\nThis does not update any of the values stored in component\n\n\n\n\n\nresiduals_and_output_jacobian!(component::ImplicitSystem, r, drdy, xsub,\n    ysub, rsub, dxsub, dysub, x, y)\n\nEvaluate the residuals and their derivatives with respect to the outputs and store the results in r and drdy.  Store the intermediate subcomponent x, y, r, drdx, and drdy values in xsub, ysub, rsub, dxsub, and dysub respectively.\n\nThis does not update any of the values stored in component\n\n\n\n\n\nresiduals_and_output_jacobian!(component::AbstractImplicitComponent, x, y)\n\nEvaluate the residuals and jacobian of the residuals with respect to the outputs.\n\nReturn the result and store in component.r and component.drdy\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals_and_output_jacobian!!","page":"Library","title":"CoupledSystems.residuals_and_output_jacobian!!","text":"residuals_and_output_jacobian!!(component::AbstractImplicitComponent, x, y)\n\nForce (re-)evaluation of the residuals and jacobian of the residuals with respect to the outputs.\n\nReturn the result and store in component.r and component.drdy\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals_and_output_jacobian!!!","page":"Library","title":"CoupledSystems.residuals_and_output_jacobian!!!","text":"residuals_and_output_jacobian!!!(component::AbstractImplicitComponent, x, y)\n\nForce (re-)evaluation of the residual and jacobian of the residuals with respect to the outputs. Also force (re-)evaluation of each subcomponents residual and jacobian with respect to its outputs.\n\nReturn the result and store in component.r and component.drdy\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals_and_jacobians","page":"Library","title":"CoupledSystems.residuals_and_jacobians","text":"residuals_and_jacobians(component::AbstractImplicitComponent)\n\nReturn the residual, its jacobian with respect to the inputs, and its jacobian with respect to the outputs stored in component.\n\n\n\n\n\nresiduals_and_jacobians(component::AbstractImplicitComponent, x, y)\n\nEvaluate the residual, its jacobian with respect to the inputs, and its jacobian with respect to the outputs.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals_and_jacobians!","page":"Library","title":"CoupledSystems.residuals_and_jacobians!","text":"residuals_and_jacobians!(component::AbstractImplicitComponent, r, drdx, drdy, x, y)\n\nEvaluate the residual, its jacobian with respect to the inputs, and its jacobian with respect to the outputs and store the results in r, drdx, and drdy\n\nThis does not update any of the values stored in component\n\n\n\n\n\nresiduals_and_jacobians!(component::ImplicitSystem, r, drdx, drdy, xsub,\n    ysub, rsub, dxsub, dysub, x, y)\n\nEvaluate the residual, its jacobian with respect to the inputs, and its jacobian with respect to the outputs and store the results in r, drdx, and drdy Store the intermediate subcomponent x, y, r, drdx, and drdy values in xsub, ysub, rsub, dxsub, and dysub respectively.\n\nThis does not update any of the values stored in component\n\n\n\n\n\nresiduals_and_jacobians!(component::AbstractImplicitComponent, x, y)\n\nEvaluate the residual, its jacobian with respect to the inputs, and its jacobian with respect to the outputs.\n\nReturn the result and store in component.r, component.drdx, and component.drdy.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals_and_jacobians!!","page":"Library","title":"CoupledSystems.residuals_and_jacobians!!","text":"residuals_and_jacobians!!(component::AbstractImplicitComponent, x, y)\n\nForce (re-)evaluation of the residual, its jacobian with respect to the inputs, and its jacobian with respect to the outputs.\n\nReturn the result and store in component.r, component.drdx, and component.drdy.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.residuals_and_jacobians!!!","page":"Library","title":"CoupledSystems.residuals_and_jacobians!!!","text":"residuals_and_jacobians!!!(component::AbstractImplicitComponent, x, y)\n\nForce (re-)evaluation of the residual, its jacobian with respect to the inputs, and its jacobian with respect to the outputs. Also force (re-)evaluation of each subcomponents residual and jacobians.\n\nReturn the result and store in component.r, component.drdx, and component.drdy.\n\n\n\n\n\n","category":"function"},{"location":"library/#Private-API","page":"Library","title":"Private API","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [CoupledSystems]\nPublic = false\n``\n\n## Index\n","category":"page"},{"location":"library/#CoupledSystems.AbstractChainRuleMode","page":"Library","title":"CoupledSystems.AbstractChainRuleMode","text":"AbstractChainRuleMode\n\nType representing direction in which to to apply the chain rule when computing the derivatives of an explicit system.\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.AbstractSensitivityMode","page":"Library","title":"CoupledSystems.AbstractSensitivityMode","text":"AbstractSensitivityMode\n\nAbstract type representing mode by which to apply the analytic sensitivity equations when computing derivatives of an explicit component created by combining an implicit component, output component, and solver.\n\n\n\n\n\n","category":"type"},{"location":"library/#CoupledSystems.allocate_jacobian","page":"Library","title":"CoupledSystems.allocate_jacobian","text":"allocate_jacobian(x, y, sparsity=DensePattern())\n\nAllocates a jacobian matrix given the inputs, outputs, and (optionally) the sparsity structure.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.analytic_sensitivity_equation","page":"Library","title":"CoupledSystems.analytic_sensitivity_equation","text":"analytic_sensitivity_equation(dfdx, dfdu, drdx, drdu, mode)\n\nCompute the sensitivities of an implicit system using the analytic sensitivity equation in Direct() or Adjoint() mode.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.create_mutating_solver_cache-Tuple{AbstractImplicitComponent,Any,AbstractSolver}","page":"Library","title":"CoupledSystems.create_mutating_solver_cache","text":"create_mutating_solver_cache(component::AbstractImplicitComponent, x, solver::AbstractSolver)\n\nConstruct a cache for a nonlinear solver which uses mutating functions.  x is a pointer to an array that will be modified to contain the correct input values.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.create_nonmutating_solver_cache-Tuple{AbstractImplicitComponent,Any,AbstractSolver}","page":"Library","title":"CoupledSystems.create_nonmutating_solver_cache","text":"create_nonmutating_solver_cache(component::AbstractImplicitComponent, x, solver::AbstractSolver)\n\nConstruct a cache for a nonlinear solver which uses nonmutating functions.  x is a pointer to an array that will be modified to contain the correct input values.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.create_output_jacobian_functions","page":"Library","title":"CoupledSystems.create_output_jacobian_functions","text":"create_output_jacobian_functions(f!, x0, y0, dtype, sp)\n\nCreates functions to compute the jacobian using the specified derivative type and sparsity pattern.\n\nArguments\n\nf!: In-place version of the output function: y = f(x)\nx0::AbstractVector: Initial values for inputs (used for size and type information)\ny0::AbstractVector: Initial values for outputs (used for size and type information)\ndtype::AbstractDiffMethod: Method used to calculate derivatives\nsparsity::AbstractSparsityPattern: Jacobian sparsity structure\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.create_residual_input_jacobian_functions","page":"Library","title":"CoupledSystems.create_residual_input_jacobian_functions","text":"create_residual_input_jacobian_functions(f!, x0, y0, r0, dtype, sp)\n\nCreates functions to compute the jacobian of the residual with respect to the inputs using the specified derivative type and sparsity pattern.\n\nArguments\n\nf!: In-place residual function f(r, x, y).\nx0: Initial values for inputs (used for size and type information)\ny0: Initial values for outputs (used for size and type information)\nr0: Initial values for residuals (used for size and type information)\ndtype: Method to use to calculate derivatives\nsparsity: Jacobian sparsity structure\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.create_residual_output_jacobian_functions","page":"Library","title":"CoupledSystems.create_residual_output_jacobian_functions","text":"create_residual_output_jacobian_functions(f!, x0, y0, r0, dtype, sp)\n\nCreates functions to compute the jacobian of the residual with respect to the inputs using the specified derivative type and sparsity pattern.\n\nArguments\n\nf!: In-place residual function f(r, x, y).\nx0: Initial values for inputs (used for size and type information)\ny0: Initial values for outputs (used for size and type information)\nr0: Initial values for residuals (used for size and type information)\ndtype: Method to use to calculate derivatives\nsparsity: Jacobian sparsity structure\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.finitediff_type","page":"Library","title":"CoupledSystems.finitediff_type","text":"finitediff_type(mode::AbstractFD)\n\nConverts the types used by this package to the inputs expected by the FiniteDiff package.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.forward_mode_jacobian!","page":"Library","title":"CoupledSystems.forward_mode_jacobian!","text":"forward_mode_jacobian!(component::ExplicitSystem, dydx, dsub=nothing)\n\nFills in the system jacobian matrix dydx using the chain rule in forward mode.\n\nIf dsub is not provided, jacobian matrices will be taken from each subcomponent's internal storage.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.forward_mode_jacobian_branch!","page":"Library","title":"CoupledSystems.forward_mode_jacobian_branch!","text":"forward_mode_jacobian_branch!(system, dydx, ix, cprod, jc, jx, dsub=nothing)\n\nAdds to the jacobian matrix using the chain rule in forward mode.\n\nThis function is called recursively to create new branches as necessary.\n\nIf dsub is not provided, jacobian matrices will be taken from each subcomponent's internal storage.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.forward_mode_mapping-NTuple{4,Any}","page":"Library","title":"CoupledSystems.forward_mode_mapping","text":"forward_mode_mapping(inputs, components, component_input_mapping, output_mapping)\n\nReturns (input_mapping, component_output_mapping) where input_mapping contains a mapping from each system input to component inputs and/or system outputs and reversed_component_mapping contains a mapping from each component output to corresponding component inputs and/or system outputs.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.getsparsity-Tuple{DensePattern,Any,Any}","page":"Library","title":"CoupledSystems.getsparsity","text":"getsparsity(::DensePattern, nx, nf)\n\nGet rows and cols for dense jacobian\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.getsparsity-Tuple{SparsePattern,Any,Any}","page":"Library","title":"CoupledSystems.getsparsity","text":"getsparsity(sp::SparsePattern, nx, nf)\n\nGet rows and cols for sparse jacobian\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.inputs-Tuple{AbstractComponent}","page":"Library","title":"CoupledSystems.inputs","text":"inputs(component::AbstractComponent)\n\nReturn the inputs corresponding to the outputs stored in component\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.reverse_mode_jacobian!","page":"Library","title":"CoupledSystems.reverse_mode_jacobian!","text":"reverse_mode_jacobian!(component::ExplicitSystem, dydx, dsub=nothing)\n\nFills in the system jacobian matrix dydx using the chain rule in reverse mode.\n\nIf dsub is not provided, jacobian matrices will be taken from each subcomponent's internal storage.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.reverse_mode_jacobian_branch!","page":"Library","title":"CoupledSystems.reverse_mode_jacobian_branch!","text":"reverse_mode_jacobian_branch!(component::ExplicitSystem, dydx, iy, cprod, jc,\n    jy, dsub=nothing)\n\nAdds to the jacobian matrix using the chain rule in reverse mode.\n\nThis function is called recursively to create new branches as necessary.\n\nIf dsub is not provided, jacobian matrices will be taken from each subcomponent's internal storage.\n\n\n\n\n\n","category":"function"},{"location":"library/#CoupledSystems.subcomponent_input_jacobians!!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_input_jacobians!!","text":"subcomponent_input_jacobians!!(component::ImplicitSystem, x, y)\n\nForce (re-)evaluation the input jacobians of an implicit system's subcomponents.\n\nStore in the x_dfdx, y_dfdx, and drdx fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_input_jacobians!-Tuple{ImplicitSystem,Any,Any,Any,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_input_jacobians!","text":"subcomponent_input_jacobians!(component::ImplicitSystem, xsub, ysub, dsub, x, y)\n\nEvaluate the input jacobians of an implicit system's subcomponents. Store the results in xsub, ysub, and dsub.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_input_jacobians!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_input_jacobians!","text":"subcomponent_input_jacobians!(component::ImplicitSystem, x, y)\n\nEvaluate the input jacobians of an implicit system's subcomponents.\n\nStore in the x_dfdx, y_dfdx, and drdx fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_output_jacobians!!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_output_jacobians!!","text":"subcomponent_output_jacobians!!(component::ImplicitSystem, x, y)\n\nForce (re-)evaluation the output jacobians of an implicit system's subcomponents.\n\nStore in the x_dfdy, y_dfdy, and drdy fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_output_jacobians!-Tuple{ImplicitSystem,Any,Any,Any,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_output_jacobians!","text":"subcomponent_output_jacobians!(component::ImplicitSystem, xsub, ysub, dsub, x, y)\n\nEvaluate the output jacobians of an implicit system's subcomponents. Store the results in xsub, ysub, and dsub.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_output_jacobians!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_output_jacobians!","text":"subcomponent_output_jacobians!(component::ImplicitSystem, x, y)\n\nEvaluate the output jacobians of an implicit system's subcomponents.\n\nStore in the x_dfdy, y_dfdy, and drdy fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_outputs!!-Tuple{Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_outputs!!","text":"subcomponent_outputs!!(component::ExplicitSystem, x)\n\nForce re-evaluation of the inputs and outputs of an explicit system's subcomponents.\n\nStore in the x_f and y fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_outputs!-NTuple{4,Any}","page":"Library","title":"CoupledSystems.subcomponent_outputs!","text":"subcomponent_outputs!(component::ExplicitSystem, xsub, ysub, x)\n\nEvaluate the inputs and outputs of an explicit systems subcomponents and store the results in xsub and ysub.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_outputs!-Tuple{Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_outputs!","text":"subcomponent_outputs!(component::ExplicitSystem, x)\n\nEvaluate the inputs and outputs of an explicit system's subcomponents.\n\nStore in the x_f and y fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_outputs_and_jacobians!!-Tuple{ExplicitSystem,Any}","page":"Library","title":"CoupledSystems.subcomponent_outputs_and_jacobians!!","text":"subcomponent_outputs_and_jacobians!!(component::ExplicitSystem, x)\n\nForce (re-)evaluation of inputs, outputs, and jacobians of an explicit system's subcomponents.\n\nStore in the x_f, y, and dydx fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_outputs_and_jacobians!-Tuple{ExplicitSystem,Any,Any,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_outputs_and_jacobians!","text":"subcomponent_outputs_and_jacobians!(component::ExplicitSystem, xsub, ysub, dsub, x)\n\nEvaluate the inputs, outputs, and jacobians of an explicit system's subcomponents. Store the results in xsub, ysub, and dsub.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_outputs_and_jacobians!-Tuple{ExplicitSystem,Any}","page":"Library","title":"CoupledSystems.subcomponent_outputs_and_jacobians!","text":"subcomponent_outputs_and_jacobians!(component::ExplicitSystem, x)\n\nEvaluate the inputs, outputs, and jacobians of an explicit system's subcomponents.\n\nStore in the x_f, y, and dydx fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_residuals!!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_residuals!!","text":"subcomponent_residuals!!(component::ImplicitSystem, x, y)\n\nForce re-evaluation of the residuals of an explicit system's subcomponents.\n\nStore in the x_f, y_f, and r fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_residuals!-Tuple{ImplicitSystem,Any,Any,Any,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_residuals!","text":"subcomponent_residuals!(component::ImplicitSystem, xsub, ysub, rsub, x, y)\n\nEvaluate the residuals of an implicit system's subcomponents and store the results in xsub, ysub, and rsub.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_residuals!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_residuals!","text":"subcomponent_residuals!(component::ImplicitSystem, x, y)\n\nEvaluate the residuals of an implicit system's subcomponents.\n\nStore in the x_f, y_f, and r fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_residuals_and_input_jacobians!!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_residuals_and_input_jacobians!!","text":"subcomponent_residuals_and_input_jacobians!!(component::ImplicitSystem, x, y)\n\nForce (re-)evaluation the residuals and input jacobians of an implicit system's subcomponents.\n\nStore in the x_dfdx, y_dfdx, r, and drdx fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_residuals_and_input_jacobians!-Tuple{ImplicitSystem,Any,Any,Any,Any,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_residuals_and_input_jacobians!","text":"subcomponent_residuals_and_input_jacobians!(component::ImplicitSystem, xsub,\n    ysub, rsub, dsub, x, y)\n\nEvaluate the residuals and input jacobians of an implicit system's subcomponents. Store the results in xsub, ysub, rsub, and dsub.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_residuals_and_input_jacobians!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_residuals_and_input_jacobians!","text":"subcomponent_residuals_and_input_jacobians!(component::ImplicitSystem, x, y)\n\nEvaluate the residuals and input jacobians of an implicit system's subcomponents.\n\nStore in the x_dfdx, y_dfdx, r, and drdx fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_residuals_and_jacobians!!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_residuals_and_jacobians!!","text":"subcomponent_residuals_and_jacobians!!(component::ImplicitSystem, x, y)\n\nForce (re-)evaluation of the residuals and output jacobians of an implicit system's subcomponents.\n\nStore in the x_dfdy, y_dfdy, r, and drdy fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_residuals_and_jacobians!-Tuple{ImplicitSystem,Any,Any,Any,Any,Any,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_residuals_and_jacobians!","text":"subcomponent_residuals_and_jacobians!(component::ImplicitSystem, xsub,\n    ysub, rsub, dsub, x, y)\n\nEvaluate the residuals and jacobians of an implicit system's subcomponents. Store the results in xsub, ysub, rsub, dxsub, and dysub.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_residuals_and_jacobians!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_residuals_and_jacobians!","text":"subcomponent_residuals_and_jacobians!(component::ImplicitSystem, x, y)\n\nEvaluate the residuals and jacobians of an implicit system's subcomponents.\n\nStore in the x_dfdy, y_dfdy, r, drdx, and drdy fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_residuals_and_output_jacobians!!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_residuals_and_output_jacobians!!","text":"subcomponent_residuals_and_output_jacobians!!(component::ImplicitSystem, x, y)\n\nForce (re-)evaluation of the residuals and output jacobians of an implicit system's subcomponents.\n\nStore in the x_dfdy, y_dfdy, r, and drdy fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_residuals_and_output_jacobians!-Tuple{ImplicitSystem,Any,Any,Any,Any,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_residuals_and_output_jacobians!","text":"subcomponent_residuals_and_output_jacobians!(component::ImplicitSystem, xsub,\n    ysub, rsub, dsub, x, y)\n\nEvaluate the residuals and output jacobians of an implicit system's subcomponents. Store the results in xsub, ysub, rsub, and dsub.\n\nThis does not update any of the values stored in component\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.subcomponent_residuals_and_output_jacobians!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.subcomponent_residuals_and_output_jacobians!","text":"subcomponent_residuals_and_output_jacobians!(component::ImplicitSystem, x, y)\n\nEvaluate the residuals and output jacobians of an implicit system's subcomponents.\n\nStore in the x_dfdy, y_dfdy, r, and drdy fields of each subcomponent.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.update_system_input_jacobian!-Tuple{ImplicitSystem,Any,Any}","page":"Library","title":"CoupledSystems.update_system_input_jacobian!","text":"update_system_input_jacobian!(system::ImplicitSystem, drdx, dsub)\n\nUpdate the input jacobian drdx to correspond to the subcomponent input jacobians in dsub.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.update_system_input_jacobian!-Tuple{ImplicitSystem}","page":"Library","title":"CoupledSystems.update_system_input_jacobian!","text":"update_system_input_jacobian!(system::ImplicitSystem)\n\nUpdate the input jacobian matrix in component to correspond to the subcomponent residuals.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.update_system_output_jacobian!-Tuple{ImplicitSystem,Any,Any,Any}","page":"Library","title":"CoupledSystems.update_system_output_jacobian!","text":"update_system_output_jacobian!(system::ImplicitSystem, drdy, dsub)\n\nUpdate the output jacobian drdy to correspond to the subcomponent output jacobians in dsub.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.update_system_output_jacobian!-Tuple{ImplicitSystem}","page":"Library","title":"CoupledSystems.update_system_output_jacobian!","text":"update_system_output_jacobian!(system::ImplicitSystem)\n\nUpdate the output jacobian in system to correspond to the subcomponent input and output jacobians.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.update_system_outputs!-NTuple{4,Any}","page":"Library","title":"CoupledSystems.update_system_outputs!","text":"update_system_outputs!(component, y, x, ysub)\n\nUpdate the outputs y given the inputs x and the component outputs ysub.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.update_system_outputs!-Tuple{Any,Any}","page":"Library","title":"CoupledSystems.update_system_outputs!","text":"update_system_outputs!(component, x)\n\nUpdate the outputs in component given the inputs x.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.update_system_residuals!-Tuple{Any,Any,Any}","page":"Library","title":"CoupledSystems.update_system_residuals!","text":"update_system_residuals!(component, r, rsub)\n\nUpdate the residuals r to make them correspond to the subcomponent residuals in rsub.\n\n\n\n\n\n","category":"method"},{"location":"library/#CoupledSystems.update_system_residuals!-Tuple{Any}","page":"Library","title":"CoupledSystems.update_system_residuals!","text":"update_system_residuals!(component)\n\nUpdate the residuals in component to correspond to the subcomponent residuals.\n\n\n\n\n\n","category":"method"},{"location":"library/","page":"Library","title":"Library","text":"@index ```","category":"page"},{"location":"#CoupledSystems","page":"Home","title":"CoupledSystems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Easily model and obtain analytic derivatives of arbitrarily complex coupled systems","category":"page"},{"location":"","page":"Home","title":"Home","text":"Author: Taylor McDonnell","category":"page"},{"location":"","page":"Home","title":"Home","text":"CoupledSystems is a modeling framework for easily modeling and obtaining exact derivatives of arbitrarily complex coupled systems.  It is similar in nature to OpenMDAO, but relies on a different theoretical foundation for propagating derivatives (and is written in Julia!).  It is also designed to automatically interface with a variety of packages in the Julia ecosystem to make obtaining derivatives and solving nonlinear systems of equations relatively painless.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Can be used to:\nPerform mixed-mode automatic differentiation\nConstruct objective and constraint functions (with exact derivatives) for gradient-based optimization.\nEasily construct monolithic coupled systems of equations from an arbitrary number of systems of equations.\nPerform efficient sensitivity analyses and obtain exact derivatives (to machine precision)\nAutomatically calculates partial derivatives using:\nFinite Differencing (Implemented using FiniteDiff)\nForward\nCentral\nComplex Step\nAutomatic Differentiation\nForward Mode (Implemented using ForwardDiff)\nReverse Mode (Implemented using ReverseDiff)\nUser-defined analytic calculations\nAutomatically calculates total derivatives using the\nChain Rule (for explicit systems)\nForward\nReverse\nAnalytic Sensitivity Equations (for implicit systems)\nDirect\nAdjoint\nMultiple solvers available for solving implicit systems\nNewton's Method with Line Search (Implemented using NLsolve)\nUser-defined solvers\nEfficient and convenient calling interface\nOutput only, derivative only, and/or combined output and derivative calculation functions\nNon-allocating interface to reduce/eliminate run-time allocations\nAllocating interface for derivative verification using ForwardDiff\nOnly calculates new values/derivatives for each component/subcomponent if inputs have been updated (unless otherwise specified)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Enter the package manager by typing ] and then run the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add CoupledSystems","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See Getting Started: The Sellar Problem","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Martins, Joaquim R. R. A., and Ning, Andrew, Engineering Design Optimization, Cambridge University Press, 2021.","category":"page"}]
}
